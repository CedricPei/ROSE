[
  {
    "question_id": 383,
    "db_id": "government_shift",
    "question": "Find all the details of the customers who have been involved in an interaction with status `` Stuck '' and service and channel detail `` bad '' .",
    "predicted_sql": "SELECT Customers.Customer_Details FROM Customers JOIN Customer_Interactions ON Customers.Customer_ID = Customer_Interactions.Customer_ID WHERE Customer_Interactions.Status_Code = 'Stuck' AND Customer_Interactions.Services_and_Channels_Details = 'bad'",
    "gold_sql": "select t1.customer_details from customers as t1 join customer_interactions as t2 on t1.customer_id  =  t2.customer_id where t2.status_code  =  \"stuck\" and services_and_channels_details  =  \"bad\"",
    "label": true,
    "reason": "Gold False. Gold SQL recall nothing cuz 'Stuck' not upper case.",
    "evidence": ""
  },
  {
    "question_id": 388,
    "db_id": "government_shift",
    "question": "Which customers have integration platform details \"Fail\" in interactions? Give me the customer details.",
    "predicted_sql": "SELECT c.customer_details FROM integration_platform ip JOIN customer_interactions ci ON ip.customer_interaction_id = ci.customer_interaction_id JOIN customers c ON ci.customer_id = c.customer_id WHERE ip.integration_platform_details = 'Fail'",
    "gold_sql": "SELECT DISTINCT t1.customer_details FROM customers AS t1 JOIN customer_interactions AS t2 ON t1.customer_id  =  t2.customer_id JOIN integration_platform AS t3 WHERE t3.integration_platform_details  =  \"Fail\"",
    "label": true,
    "reason": "Gold False. Gold SQL not process integration_platform's join condition.",
    "evidence": ""
  },
  {
    "question_id": 433,
    "db_id": "vehicle_rent",
    "question": "What is the discount name with most number of renting history records?",
    "predicted_sql": "SELECT      T2.name  FROM      Renting_history AS T1  JOIN      Discount AS T2  ON      T1.discount_id = T2.id  GROUP BY      T2.name  ORDER BY      COUNT(*) DESC  LIMIT 1",
    "gold_sql": "SELECT T2.name FROM renting_history AS T1 JOIN discount AS T2 ON T1.discount_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1",
    "label": true,
    "reason": "Gold False. Question ask group by name, Gold SQL use id.",
    "evidence": ""
  },
  {
    "question_id": 438,
    "db_id": "vehicle_rent",
    "question": "What are the average city fuel economy rate, average highway fuel economy rate for different types of powertrains?",
    "predicted_sql": "SELECT      Type_of_powertrain,      AVG(City_fuel_economy_rate) AS avg_city_fuel_economy,      AVG(Highway_fuel_economy_rate) AS avg_highway_fuel_economy FROM      Vehicles GROUP BY      Type_of_powertrain",
    "gold_sql": "SELECT avg(City_fuel_economy_rate) ,  avg(Highway_fuel_economy_rate) , Type_of_powertrain FROM vehicles GROUP BY Type_of_powertrain",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 441,
    "db_id": "cre_Students_Information_Systems",
    "question": "List the biographical data and student id for the students who take 2 or more classes and the students who have less than 2 detentions.",
    "predicted_sql": "SELECT DISTINCT S.student_id, S.bio_data FROM Students S JOIN Classes C ON S.student_id = C.student_id GROUP BY S.student_id HAVING COUNT(C.class_id) >= 2 INTERSECT SELECT DISTINCT S.student_id, S.bio_data FROM Students S LEFT JOIN Detention D ON S.student_id = D.student_id GROUP BY S.student_id HAVING COUNT(D.detention_id) < 2",
    "gold_sql": "SELECT T1.bio_data ,  T1.student_id FROM Students AS T1 JOIN Classes AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  >=  2 UNION SELECT T1.bio_data ,  T1.student_id FROM Students AS T1 JOIN Detention AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  <  2",
    "label": false,
    "reason": "Predicted SQL use intersect, while the question ask for 2 different kind of students which need a union.",
    "evidence": ""
  },
  {
    "question_id": 448,
    "db_id": "cre_Students_Information_Systems",
    "question": "List the amount and date of loan for the students who have two or more achievements.",
    "predicted_sql": "SELECT      T1.amount_of_loan,      T1.date_of_loan FROM      Student_Loans AS T1 JOIN      Achievements AS T2  ON      T1.student_id = T2.student_id GROUP BY      T2.student_id HAVING      COUNT(*) >= 2",
    "gold_sql": "SELECT amount_of_loan ,  date_of_loan FROM Student_Loans WHERE student_id IN ( SELECT student_id FROM Achievements GROUP BY student_id HAVING count(*)  >=  2 )",
    "label": false,
    "reason": "Need select on achievement first.",
    "evidence": ""
  },
  {
    "question_id": 449,
    "db_id": "cre_Students_Information_Systems",
    "question": "List the detail and id of the teacher who teaches the most courses.",
    "predicted_sql": "SELECT T1.teacher_id, T1.teacher_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id = T2.teacher_id GROUP BY T1.teacher_id ORDER BY count(*) DESC LIMIT 1",
    "gold_sql": "SELECT T1.teacher_details ,  T1.teacher_id FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id GROUP BY T1.teacher_id ORDER BY count(*) DESC LIMIT 1",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 451,
    "db_id": "cre_Students_Information_Systems",
    "question": "What are the distinct descriptions of all the detentions which have ever happened?",
    "predicted_sql": "SELECT DISTINCT Ref_Detention_Type.detention_type_description FROM Ref_Detention_Type JOIN Detention ON Ref_Detention_Type.detention_type_description = Detention.detention_type_code",
    "gold_sql": "SELECT distinct(T1.detention_type_description) FROM Ref_Detention_Type AS T1 JOIN Detention AS T2 ON T1.detention_type_code  =  T2.detention_type_code",
    "label": false,
    "reason": "Need pair code by code rather than description",
    "evidence": ""
  },
  {
    "question_id": 452,
    "db_id": "cre_Students_Information_Systems",
    "question": "Return the distinct descriptions of all the detentions that have happened.",
    "predicted_sql": "SELECT DISTINCT detention_summary FROM detention",
    "gold_sql": "SELECT distinct(T1.detention_type_description) FROM Ref_Detention_Type AS T1 JOIN Detention AS T2 ON T1.detention_type_code  =  T2.detention_type_code",
    "label": false,
    "reason": "Totally wrong",
    "evidence": ""
  },
  {
    "question_id": 453,
    "db_id": "cre_Students_Information_Systems",
    "question": "List the personal details and the address type descriptions of all the students.",
    "predicted_sql": "SELECT T1.bio_data, T1.student_details, T3.address_type_description FROM Students AS T1 JOIN Students_Addresses AS T2 ON T1.student_id = T2.student_id JOIN Ref_Address_Types AS T3 ON T2.address_type_code = T3.address_type_code",
    "gold_sql": "SELECT DISTINCT T1.student_details ,  T3.address_type_description FROM Students AS T1 JOIN Students_Addresses AS T2 ON T1.student_id  =  T2.student_id JOIN Ref_Address_Types AS T3 ON T2.address_type_code  =  T3.address_type_code",
    "label": false,
    "reason": "One more 'bio_data' column, no distinct",
    "evidence": ""
  },
  {
    "question_id": 454,
    "db_id": "cre_Students_Information_Systems",
    "question": "What are the personal details and the address type descriptions of each student?",
    "predicted_sql": "SELECT      T1.bio_data,      T3.address_type_description  FROM      Students AS T1  JOIN      Students_Addresses AS T2  ON      T1.student_id = T2.student_id  JOIN      Ref_Address_Types AS T3  ON      T2.address_type_code = T3.address_type_code",
    "gold_sql": "SELECT DISTINCT T1.student_details ,  T3.address_type_description FROM Students AS T1 JOIN Students_Addresses AS T2 ON T1.student_id  =  T2.student_id JOIN Ref_Address_Types AS T3 ON T2.address_type_code  =  T3.address_type_code",
    "label": false,
    "reason": "ask student details, return bio_data",
    "evidence": ""
  },
  {
    "question_id": 456,
    "db_id": "cre_Students_Information_Systems",
    "question": "What are the address details and biographical information of each student?",
    "predicted_sql": "SELECT T1.bio_data , T2.address_details FROM students AS T1 JOIN students_addresses AS T3 ON T1.student_id = T3.student_id JOIN addresses AS T2 ON T3.address_id = T2.address_id",
    "gold_sql": "SELECT T1.address_details ,  T3.bio_data FROM Addresses AS T1 JOIN Students_Addresses AS T2 ON T1.address_id  =  T2.address_id JOIN Students AS T3 ON T2.student_id  =  T3.student_id",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 460,
    "db_id": "cre_Students_Information_Systems",
    "question": "Find the most common result in the behavioral monitoring details. What are the count and the details of this result?",
    "predicted_sql": "SELECT      COUNT(*) AS count,      behaviour_monitoring_details  FROM      Behaviour_Monitoring  GROUP BY      behaviour_monitoring_details  ORDER BY      count DESC  LIMIT 1",
    "gold_sql": "SELECT count(DISTINCT student_id) ,  behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY count(*) DESC LIMIT 1",
    "label": false,
    "reason": "No Distinct, counter number wrong",
    "evidence": ""
  },
  {
    "question_id": 462,
    "db_id": "cre_Students_Information_Systems",
    "question": "Find the biographical data and details of students who got not only the most common result but also a result that is obtained by 3 students in behaviour monitoring.",
    "predicted_sql": "SELECT T1.bio_data, T1.student_details FROM students AS T1 JOIN ( SELECT student_id FROM behaviour_monitoring GROUP BY student_id HAVING COUNT(behaviour_monitoring_id) = ( SELECT COUNT(*) AS count FROM behaviour_monitoring GROUP BY student_id ORDER BY count DESC LIMIT 1 ) OR COUNT(behaviour_monitoring_id) = 3 ) AS T2 ON T1.student_id = T2.student_id",
    "gold_sql": "SELECT T1.bio_data ,  T1.student_details FROM Students AS T1 JOIN Behaviour_Monitoring AS T2 ON T1.student_id  =  T2.student_id WHERE T2.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY count(*) DESC LIMIT 1 ) INTERSECT SELECT T1.bio_data ,  T1.student_details FROM Students AS T1 JOIN Behaviour_Monitoring AS T2 ON T1.student_id  =  T2.student_id WHERE T2.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details HAVING count(*)  =  3 )",
    "label": false,
    "reason": "Need to count the the most common result, predict count of behavior",
    "evidence": ""
  },
  {
    "question_id": 464,
    "db_id": "cre_Students_Information_Systems",
    "question": "What is the biographical information of the students who got the most common result for their behaviour monitoring details ?",
    "predicted_sql": "SELECT      T1.bio_data  FROM      Students AS T1  JOIN      Behaviour_Monitoring AS T2  ON      T1.student_id = T2.student_id  WHERE      T2.behaviour_monitoring_details = (         SELECT              behaviour_monitoring_details          FROM              Behaviour_Monitoring          GROUP BY              behaviour_monitoring_details          ORDER BY              COUNT(*) DESC          LIMIT 1     )",
    "gold_sql": "select t1.bio_data from students as t1 join behaviour_monitoring as t2 on t1.student_id  =  t2.student_id where t2.behaviour_monitoring_details in ( select behaviour_monitoring_details from behaviour_monitoring group by behaviour_monitoring_details order by count(*) desc limit 1 ) except select t1.bio_data from students as t1 join behaviour_monitoring as t2 on t1.student_id  =  t2.student_id where t2.behaviour_monitoring_details not in ( select behaviour_monitoring_details from behaviour_monitoring group by behaviour_monitoring_details order by count(*) desc limit 1 )",
    "label": true,
    "reason": "Gold False, need students who have most common result rather than only common result",
    "evidence": ""
  },
  {
    "question_id": 482,
    "db_id": "cre_Students_Information_Systems",
    "question": "What are the pairs of teachers and students who are in the same class? Give me the pairs of their details.",
    "predicted_sql": "SELECT T1.teacher_details AS teacher_name, T2.bio_data AS student_name FROM Classes AS T3 JOIN Teachers AS T1 ON T3.teacher_id = T1.teacher_id JOIN Students AS T2 ON T3.student_id = T2.student_id",
    "gold_sql": "SELECT T1.teacher_details ,  T3.student_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id JOIN Students AS T3 ON T2.student_id  =  T3.student_id",
    "label": false,
    "reason": "Need details, return names.",
    "evidence": ""
  },
  {
    "question_id": 483,
    "db_id": "cre_Students_Information_Systems",
    "question": "How many courses do teachers teach at most? Also find the id of the teacher who teaches the most.",
    "predicted_sql": "SELECT teacher_id, COUNT(*) AS course_count FROM Classes GROUP BY teacher_id ORDER BY course_count DESC LIMIT 1",
    "gold_sql": "SELECT count(*) ,  teacher_id FROM Classes GROUP BY teacher_id ORDER BY count(*) DESC LIMIT 1",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 486,
    "db_id": "cre_Students_Information_Systems",
    "question": "Which student is taking the most courses? Give me the id of the student and the number of courses he or she is taking.",
    "predicted_sql": "SELECT student_id, COUNT(class_id) FROM classes GROUP BY student_id ORDER BY COUNT(class_id) DESC LIMIT 1;",
    "gold_sql": "SELECT count(*) ,  student_id FROM Classes GROUP BY student_id ORDER BY count(*) DESC LIMIT 1",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 497,
    "db_id": "cre_Students_Information_Systems",
    "question": "When was the transcript issued for the student with loan of maximum value?",
    "predicted_sql": "SELECT date_of_transcript FROM Transcripts WHERE student_id = (     SELECT student_id     FROM Student_Loans     ORDER BY amount_of_loan DESC     LIMIT 1 )",
    "gold_sql": "SELECT T1.date_of_transcript FROM Transcripts AS T1 JOIN Student_Loans AS T2 ON T1.student_id  =  T2.student_id ORDER BY T2.amount_of_loan DESC LIMIT 1",
    "label": true,
    "reason": "Gold False. May count student multiple times",
    "evidence": ""
  },
  {
    "question_id": 502,
    "db_id": "cre_Students_Information_Systems",
    "question": "For each student, find the student id and the total amount of loan he or she has.",
    "predicted_sql": "SELECT sum(amount_of_loan), student_id FROM student_loans GROUP BY student_id",
    "gold_sql": "SELECT student_id ,  sum(amount_of_loan) FROM Student_Loans GROUP BY student_id",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 536,
    "db_id": "book_1",
    "question": "What are all isbns for each book, and how many times has each been ordered?",
    "predicted_sql": "SELECT T1.ISBN, COUNT(T2.IdOrder) FROM Book AS T1 LEFT JOIN Books_Order AS T2 ON T1.ISBN = T2.ISBN GROUP BY T1.ISBN",
    "gold_sql": "SELECT isbn ,  count(*) FROM Books_Order GROUP BY isbn",
    "label": true,
    "reason": "Gold False. Gold forgot the 0 ordered books.",
    "evidence": ""
  },
  {
    "question_id": 548,
    "db_id": "book_1",
    "question": "What are the names of all the clients, and how many times has each of them ordered?",
    "predicted_sql": "SELECT Client.Name, COUNT(Orders.IdOrder) FROM Client LEFT JOIN Orders ON Client.IdClient = Orders.IdClient GROUP BY Client.Name",
    "gold_sql": "SELECT T2.name ,  count(*) FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient GROUP BY T1.idClient",
    "label": true,
    "reason": "Gold False. Ingored 0 ordeer clients",
    "evidence": ""
  },
  {
    "question_id": 554,
    "db_id": "book_1",
    "question": "What is the name of the client who has ordered the greatest total amount of books?",
    "predicted_sql": "SELECT T1.name FROM client AS T1 JOIN orders AS T2 ON T1.idclient = T2.idclient JOIN books_order AS T3 ON T2.idorder = T3.idorder GROUP BY T1.name ORDER BY sum(T3.amount) DESC LIMIT 1",
    "gold_sql": "SELECT T2.name FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient JOIN Books_Order AS T3 ON T3.idOrder  =  T1.idOrder GROUP BY T1.idClient ORDER BY sum(T3.amount) DESC LIMIT 1",
    "label": false,
    "reason": "Group by name may count different clients with the same name.",
    "evidence": ""
  },
  {
    "question_id": 578,
    "db_id": "book_1",
    "question": "Give the titles of books authored by Plato that have a sale price lower than the average sale price across all books.",
    "predicted_sql": "SELECT `Book`.`Title` FROM `Book` JOIN `Author_Book` ON `Book`.`Author` = `Author_Book`.`Author` JOIN `Author` ON `Author_Book`.`Author` = `Author`.`idAuthor` WHERE `Author`.`Name` = 'Plato' AND `Book`.`SalePrice` < (SELECT avg(`SalePrice`) FROM `Book`)",
    "gold_sql": "SELECT T1.title FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name  =  \"Plato\" AND T1.saleprice  <  (SELECT avg(saleprice) FROM Book)",
    "label": false,
    "reason": "Wrong join conditions.",
    "evidence": ""
  },
  {
    "question_id": 597,
    "db_id": "book_review",
    "question": "What are the maximum and minimum number of chapters for each book?",
    "predicted_sql": "SELECT max(chapters), min(chapters), book_id FROM book GROUP BY book_id",
    "gold_sql": "SELECT max(Chapters) ,  min(Chapters) FROM book",
    "label": true,
    "reason": "Gold False. Ask for each book rather than all books.",
    "evidence": ""
  },
  {
    "question_id": 1006,
    "db_id": "aan_1",
    "question": "Give the id and the number of citations of the most cited paper.",
    "predicted_sql": "SELECT cited_paper_id, COUNT(*) AS citation_count FROM Citation GROUP BY cited_paper_id ORDER BY citation_count DESC LIMIT 1",
    "gold_sql": "SELECT paper_id ,  count(*) FROM Citation GROUP BY cited_paper_id ORDER BY count(*) DESC LIMIT 1",
    "label": true,
    "reason": "Gold False. Need most cited paper's id.",
    "evidence": ""
  },
  {
    "question_id": 1009,
    "db_id": "aan_1",
    "question": "List top 10 most cited papers and their numbers of citations.",
    "predicted_sql": "SELECT      Paper.title,      COUNT(*) AS citation_count FROM      Citation JOIN      Paper  ON      Citation.cited_paper_id = Paper.paper_id GROUP BY      Citation.cited_paper_id ORDER BY      citation_count DESC LIMIT 10",
    "gold_sql": "SELECT paper_id ,  count(*) FROM Citation GROUP BY cited_paper_id ORDER BY count(*) DESC LIMIT 10",
    "label": true,
    "reason": "id and title both OK.",
    "evidence": ""
  },
  {
    "question_id": 1010,
    "db_id": "aan_1",
    "question": "What are the 10 most cited papers, and how many citations did each have?",
    "predicted_sql": "SELECT      p.title,      COUNT(*) AS citation_count FROM      Citation c JOIN      Paper p ON      c.cited_paper_id = p.paper_id GROUP BY      p.title ORDER BY      citation_count DESC LIMIT 10",
    "gold_sql": "SELECT paper_id ,  count(*) FROM Citation GROUP BY cited_paper_id ORDER BY count(*) DESC LIMIT 10",
    "label": true,
    "reason": "id and title both OK.",
    "evidence": ""
  },
  {
    "question_id": 1015,
    "db_id": "aan_1",
    "question": "Find the name and number of citations of the author who has most citations among all authors?",
    "predicted_sql": "SELECT T1.name, COUNT(T3.cited_paper_id) AS citation_count FROM Author AS T1 JOIN Author_list AS T2 ON T1.author_id = T2.author_id JOIN Citation AS T3 ON T2.paper_id = T3.paper_id GROUP BY T1.author_id ORDER BY citation_count DESC LIMIT 1",
    "gold_sql": "SELECT T3.name ,  count(*) FROM Citation AS T1 JOIN Author_list AS T2 ON T1.cited_paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id GROUP BY T2.author_id ORDER BY count(*) DESC LIMIT 1",
    "label": false,
    "reason": "Need most citation rather than cite others most",
    "evidence": ""
  },
  {
    "question_id": 1019,
    "db_id": "aan_1",
    "question": "What are the venues and years where Columbia University had papers ?",
    "predicted_sql": "SELECT DISTINCT      Paper.venue,      Paper.year FROM      Affiliation JOIN      Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN      Paper ON Author_list.paper_id = Paper.paper_id WHERE      Affiliation.name = 'Columbia University'",
    "gold_sql": "select distinct t1.venue ,  t1.year from paper as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join affiliation as t3 on t2.affiliation_id  =  t3.affiliation_id where t3.name = \"columbia university\"",
    "label": true,
    "reason": "Gold False. Upper case.",
    "evidence": ""
  },
  {
    "question_id": 1020,
    "db_id": "aan_1",
    "question": "Which venues and years did Columbia University have papers ?",
    "predicted_sql": "SELECT DISTINCT T1.venue, T1.year FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id = T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id = T3.affiliation_id WHERE T3.name = 'Columbia University'",
    "gold_sql": "select distinct t1.venue ,  t1.year from paper as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join affiliation as t3 on t2.affiliation_id  =  t3.affiliation_id where t3.name = \"columbia university\"",
    "label": true,
    "reason": "Gold False. Uppercase.",
    "evidence": ""
  },
  {
    "question_id": 1025,
    "db_id": "aan_1",
    "question": "How many papers does Columbia University have in or before 2009 ?",
    "predicted_sql": "SELECT count(*) FROM paper AS T1 JOIN author_list AS T2 ON T1.paper_id = T2.paper_id JOIN affiliation AS T3 ON T2.affiliation_id = T3.affiliation_id WHERE T3.name = \"Columbia University\" and T1.year <= 2009;",
    "gold_sql": "select count(distinct t1.paper_id) from paper as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join affiliation as t3 on t2.affiliation_id  =  t3.affiliation_id where t1.year  <=  2009 and t3.name = \"columbia university\"",
    "label": true,
    "reason": "Gold False. Uppercase.",
    "evidence": ""
  },
  {
    "question_id": 1041,
    "db_id": "aan_1",
    "question": "Find the number of papers published in different conferences each year.",
    "predicted_sql": "SELECT year, venue, COUNT(*) AS paper_count FROM Paper GROUP BY year, venue",
    "gold_sql": "SELECT count(*) ,  venue ,  YEAR FROM Paper GROUP BY venue ,  YEAR",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1047,
    "db_id": "aan_1",
    "question": "Find the number of authors who did not publish any paper that is cited more than 50 times.",
    "predicted_sql": "WITH CitedPapers AS (     SELECT cited_paper_id     FROM Citation     GROUP BY cited_paper_id     HAVING COUNT(*) > 50 ),  AuthorsOfCitedPapers AS (     SELECT DISTINCT author_id     FROM Author_list     WHERE paper_id IN (SELECT cited_paper_id FROM CitedPapers) ),  AuthorsNotCited AS (     SELECT author_id     FROM Author     EXCEPT     SELECT author_id     FROM AuthorsOfCitedPapers )  SELECT COUNT(*) AS author_count FROM AuthorsNotCited",
    "gold_sql": "SELECT count(*) FROM Author WHERE Author_id NOT IN ( SELECT T2.author_id FROM Citation AS T1 JOIN Author_list AS T2 ON T1.cited_paper_id  =  T2.paper_id GROUP BY T1.cited_paper_id HAVING count(DISTINCT T1.paper_id)  >  50)",
    "label": true,
    "reason": "Gold False. No group by authors, may count a author multiple times.",
    "evidence": ""
  },
  {
    "question_id": 1059,
    "db_id": "conference",
    "question": "Show all conference names and the number of times each conference has.",
    "predicted_sql": "SELECT T2.conference_name, count(*) FROM conference_participation AS T1 JOIN conference AS T2 ON T1.conference_id = T2.conference_id GROUP BY T2.conference_id",
    "gold_sql": "SELECT conference_name ,  count(*) FROM conference GROUP BY conference_name",
    "label": false,
    "reason": "No combine conference by names.",
    "evidence": ""
  },
  {
    "question_id": 1074,
    "db_id": "conference",
    "question": "For each institution id , how many staff members does each institution have that was founded after 1800 ? return their names .",
    "predicted_sql": "SELECT T1.Institution_ID, COUNT(T2.name) AS staff_count, GROUP_CONCAT(T2.name) AS staff_names FROM institution AS T1 JOIN staff AS T2 ON T1.Institution_ID = T2.Institution_ID WHERE T1.Founded > 1800 GROUP BY T1.Institution_ID",
    "gold_sql": "select t1.institution_name ,  count(*) from institution as t1 join staff as t2 on t1.institution_id  =  t2.institution_id where t1.founded  >  1800 group by t2.institution_id",
    "label": true,
    "reason": "Gold False. No names",
    "evidence": ""
  },
  {
    "question_id": 1090,
    "db_id": "conference",
    "question": "For each conference id, what are their names, year, and number of participants?",
    "predicted_sql": "SELECT T1.conference_id, T1.conference_name, T1.year, count(*) AS number_of_participants FROM conference AS T1 JOIN conference_participation AS T2 ON T1.conference_id = T2.conference_id GROUP BY T1.conference_id",
    "gold_sql": "SELECT T1.conference_name ,  T1.year ,  count(*) FROM Conference AS T1 JOIN Conference_participation AS T2 ON T1.conference_id  =  T2.conference_id GROUP BY T2.conference_id",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1095,
    "db_id": "conference",
    "question": "Find the name and location of the universities that did not have any staff participated in any conference in 2004.",
    "predicted_sql": "SELECT      institution.Institution_Name,      institution.Location FROM      institution WHERE      institution.Institution_ID NOT IN (         SELECT              staff.Institution_ID         FROM              conference_participation         JOIN              conference         ON              conference_participation.Conference_ID = conference.Conference_ID         JOIN              staff         ON              conference_participation.staff_ID = staff.staff_ID         WHERE              conference.Year = 2004     )",
    "gold_sql": "SELECT T1.Institution_Name ,  T1.location FROM institution AS T1 JOIN staff AS T2 ON T1.institution_id  =  T2.institution_id WHERE T2.staff_id NOT IN (SELECT T4.staff_id FROM Conference AS T3 JOIN Conference_participation AS T4 ON T3.conference_id  =  T4.conference_id WHERE T3.year  =  2004)",
    "label": true,
    "reason": "Gold False. Ignore 0 staff items.",
    "evidence": ""
  },
  {
    "question_id": 1129,
    "db_id": "pilot_1",
    "question": "How many planes are controlled by the pilots whose age is older than 40?",
    "predicted_sql": "SELECT count(DISTINCT plane_name) FROM pilotskills WHERE age > 40",
    "gold_sql": "SELECT count(plane_name) FROM pilotskills WHERE age  >  40",
    "label": true,
    "reason": "Gold False. No distinct",
    "evidence": ""
  },
  {
    "question_id": 1138,
    "db_id": "pilot_1",
    "question": "What are the different plane names, ordered alphabetically?",
    "predicted_sql": "SELECT DISTINCT plane_name FROM Hangar ORDER BY plane_name",
    "gold_sql": "SELECT DISTINCT plane_name FROM pilotskills ORDER BY plane_name",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1139,
    "db_id": "pilot_1",
    "question": "How many pilots who are older than 40 or younger than 30?",
    "predicted_sql": "SELECT count(*) FROM pilotskills WHERE age > 40 OR age < 30",
    "gold_sql": "SELECT count(pilot_name) FROM pilotskills ORDER BY age  >  40 OR age  <  30",
    "label": true,
    "reason": "Gold False. Order by no filter",
    "evidence": ""
  },
  {
    "question_id": 1153,
    "db_id": "pilot_1",
    "question": "What is the average age of pilots for different types of planes?",
    "predicted_sql": "SELECT plane_name, avg(age) FROM PilotSkills GROUP BY plane_name",
    "gold_sql": "SELECT avg(age) ,  plane_name FROM pilotskills GROUP BY plane_name",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1154,
    "db_id": "pilot_1",
    "question": "Return the average age of pilots for each plane name.",
    "predicted_sql": "SELECT plane_name , avg(age) FROM pilotskills GROUP BY plane_name",
    "gold_sql": "SELECT avg(age) ,  plane_name FROM pilotskills GROUP BY plane_name",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1155,
    "db_id": "pilot_1",
    "question": "Find the number of planes for each type.",
    "predicted_sql": "SELECT plane_name, count(*) FROM pilotskills GROUP BY plane_name;",
    "gold_sql": "SELECT count(*) ,  plane_name FROM pilotskills GROUP BY plane_name",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1158,
    "db_id": "pilot_1",
    "question": "What are the different plane names, and what are the names of the oldest pilot who has each, ordered by plane name?",
    "predicted_sql": "SELECT T1.plane_name, T2.pilot_name FROM hangar AS T1 LEFT JOIN pilotskills AS T2 ON T1.plane_name = T2.plane_name GROUP BY T1.plane_name ORDER BY MAX(T2.age) DESC, T1.plane_name ASC",
    "gold_sql": "SELECT pilot_name ,  plane_name ,  max(age) FROM pilotskills GROUP BY plane_name ORDER BY plane_name",
    "label": false,
    "reason": "wrong table. hanger may select no pilot planes.",
    "evidence": ""
  },
  {
    "question_id": 1159,
    "db_id": "pilot_1",
    "question": "What are the names of oldest pilots for each type of plane?",
    "predicted_sql": "SELECT      ps1.plane_name,      ps1.pilot_name  FROM      PilotSkills ps1 JOIN      (SELECT           plane_name,           MAX(age) AS max_age       FROM           PilotSkills       GROUP BY           plane_name) ps2 ON      ps1.plane_name = ps2.plane_name      AND ps1.age = ps2.max_age",
    "gold_sql": "SELECT pilot_name ,  plane_name ,  max(age) FROM pilotskills GROUP BY plane_name",
    "label": false,
    "reason": "Wrong age subtable.",
    "evidence": ""
  },
  {
    "question_id": 1161,
    "db_id": "pilot_1",
    "question": "Find the max age for each group of pilots with the same name.",
    "predicted_sql": "SELECT pilot_name, MAX(age) AS max_age FROM PilotSkills GROUP BY pilot_name",
    "gold_sql": "SELECT max(age) ,  pilot_name FROM pilotskills GROUP BY pilot_name",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1162,
    "db_id": "pilot_1",
    "question": "What are the different pilot names, and what are the maximum ages of pilots for each?",
    "predicted_sql": "SELECT pilot_name, MAX(age) AS max_age FROM PilotSkills GROUP BY pilot_name",
    "gold_sql": "SELECT max(age) ,  pilot_name FROM pilotskills GROUP BY pilot_name",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1166,
    "db_id": "pilot_1",
    "question": "What are the different plane names of planes with an average pilot age of below 35, and how many pilots have flown each of them?",
    "predicted_sql": "SELECT T1.plane_name, COUNT(T1.pilot_name) FROM PilotSkills AS T1 JOIN Hangar AS T2 ON T1.plane_name = T2.plane_name GROUP BY T1.plane_name HAVING AVG(T1.age) < 35",
    "gold_sql": "SELECT count(*) ,  plane_name FROM pilotskills GROUP BY plane_name HAVING avg(age)  <  35",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1183,
    "db_id": "district_spokesman",
    "question": "What is the total population of the districts whose areas are in the top 3?",
    "predicted_sql": "SELECT sum(d.population) FROM district d JOIN ( SELECT district_id FROM district ORDER BY area_km DESC LIMIT 3 ) top_areas ON d.district_id = top_areas.district_id",
    "gold_sql": "SELECT sum(population) FROM district ORDER BY area_km DESC LIMIT 3",
    "label": true,
    "reason": "Gold False. Sum the whole table.",
    "evidence": ""
  },
  {
    "question_id": 1553,
    "db_id": "bakery_1",
    "question": "What is average price of goods whose flavor is blackberry or blueberry?",
    "predicted_sql": "SELECT avg(Price) FROM goods WHERE Flavor = 'blackberry' OR Flavor = 'blueberry'",
    "gold_sql": "SELECT avg(price) FROM goods WHERE flavor  =  \"Blackberry\" OR flavor  =  \"Blueberry\"",
    "label": false,
    "reason": "uppercase",
    "evidence": ""
  },
  {
    "question_id": 1557,
    "db_id": "bakery_1",
    "question": "What are highest, lowest, and average prices of goods, grouped and ordered by flavor?",
    "predicted_sql": "SELECT flavor , max(price) , min(price) , avg(price) FROM goods GROUP BY flavor ORDER BY flavor",
    "gold_sql": "SELECT max(price) ,  min(price) ,  avg(price) ,  flavor FROM goods GROUP BY flavor ORDER BY flavor",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1558,
    "db_id": "bakery_1",
    "question": "What are the maximum, minimum, and average prices of goods of each flavor, ordered by flavor?",
    "predicted_sql": "SELECT Flavor, max(Price), min(Price), avg(Price) FROM goods GROUP BY Flavor ORDER BY Flavor",
    "gold_sql": "SELECT max(price) ,  min(price) ,  avg(price) ,  flavor FROM goods GROUP BY flavor ORDER BY flavor",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1559,
    "db_id": "bakery_1",
    "question": "Return the lowest and highest prices of goods grouped and ordered by food type.",
    "predicted_sql": "SELECT Food, min(Price), max(Price) FROM goods GROUP BY Food ORDER BY Food",
    "gold_sql": "SELECT min(price) ,  max(price) ,  food FROM goods GROUP BY food ORDER BY food",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1563,
    "db_id": "bakery_1",
    "question": "Which customer shopped most often? How many times?",
    "predicted_sql": "SELECT t1.LastName, t1.FirstName, COUNT(t2.ReceiptNumber) AS shop_count FROM customers AS t1 JOIN receipts AS t2 ON t1.Id = t2.CustomerId GROUP BY t1.Id ORDER BY shop_count DESC LIMIT 1",
    "gold_sql": "SELECT CustomerId ,  count(*) FROM receipts GROUP BY CustomerId ORDER BY count(*) DESC LIMIT 1",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1566,
    "db_id": "bakery_1",
    "question": "How many cusomters visited on each date?",
    "predicted_sql": "SELECT Date, COUNT(*) AS CustomerCount FROM receipts GROUP BY Date",
    "gold_sql": "SELECT date ,  COUNT (DISTINCT CustomerId) FROM receipts GROUP BY date",
    "label": false,
    "reason": "No distinct when count",
    "evidence": ""
  },
  {
    "question_id": 1574,
    "db_id": "bakery_1",
    "question": "Give the ids of goods that are more than twice as expensive as the average good.",
    "predicted_sql": "SELECT Id FROM goods WHERE Price > 2 * (SELECT avg(Price) FROM goods)",
    "gold_sql": "SELECT id FROM goods WHERE price  >  (SELECT avg(price) FROM goods)",
    "label": true,
    "reason": "Gold False. Forget twice",
    "evidence": ""
  },
  {
    "question_id": 1580,
    "db_id": "bakery_1",
    "question": "What are the items with chocolate flavor that were purchased at most 10 times.",
    "predicted_sql": "SELECT g.flavor, g.id, g.food, COUNT(*) as purchase_count FROM goods g JOIN items i ON g.id = i.item WHERE g.flavor = 'Chocolate' GROUP BY g.id, g.flavor, g.food HAVING COUNT(*) <= 10;",
    "gold_sql": "SELECT DISTINCT T1.item FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.flavor  =  \"Chocolate\" GROUP BY item HAVING count(*)  <=  10",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1583,
    "db_id": "bakery_1",
    "question": "What is the three most popular goods in this bakery?",
    "predicted_sql": "SELECT      T1.Item,      COUNT(*) AS Popularity FROM      items AS T1 JOIN      goods AS T2  ON      T1.Item = T2.Id GROUP BY      T1.Item ORDER BY      Popularity DESC LIMIT 3",
    "gold_sql": "SELECT item FROM items GROUP BY item ORDER BY COUNT (*) DESC LIMIT 3",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1595,
    "db_id": "car_racing",
    "question": "Find the average age of drivers for each make.",
    "predicted_sql": "SELECT make, avg(age) FROM driver GROUP BY make",
    "gold_sql": "SELECT avg(age) ,  Make FROM driver GROUP BY make",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1601,
    "db_id": "car_racing",
    "question": "Find the make that has more than one team.",
    "predicted_sql": "SELECT T1.Make FROM team AS T1 JOIN team_driver AS T2 ON T1.Team_ID = T2.Team_ID GROUP BY T1.Make HAVING COUNT(*) > 1",
    "gold_sql": "SELECT make FROM team GROUP BY team HAVING count(*)  >  1",
    "label": true,
    "reason": "Gold False. No Team.Team column",
    "evidence": ""
  },
  {
    "question_id": 1602,
    "db_id": "car_racing",
    "question": "Which make has more than one team?",
    "predicted_sql": "SELECT make FROM team GROUP BY make HAVING COUNT(*) > 1",
    "gold_sql": "SELECT make FROM team GROUP BY team HAVING count(*)  >  1",
    "label": true,
    "reason": "Gold False. No Team.Team column",
    "evidence": ""
  },
  {
    "question_id": 1628,
    "db_id": "car_racing",
    "question": "Which make is associated with 3 or more drivers?",
    "predicted_sql": "SELECT T1.Make FROM team AS T1 JOIN team_driver AS T2 ON T1.Team_ID = T2.Team_ID JOIN driver AS T3 ON T2.Driver_ID = T3.Driver_ID GROUP BY T1.Make HAVING COUNT(DISTINCT T3.Driver_ID) >= 3",
    "gold_sql": "SELECT Make FROM driver GROUP BY Make HAVING COUNT(*)  >=  3",
    "label": true,
    "reason": "Gold False. Need distinct driverID.",
    "evidence": ""
  },
  {
    "question_id": 1631,
    "db_id": "car_racing",
    "question": "Which country has both drivers with make \"Dodge\" and drivers with make \"Chevrolet\"?",
    "predicted_sql": "SELECT country FROM driver WHERE make = \"Dodge\" INTERSECT SELECT country FROM driver WHERE make = \"Chevrolet\"",
    "gold_sql": "SELECT t2.country FROM driver AS t1 JOIN country AS t2 ON t1.country  =  t2.country_id WHERE t1.Make  =  \"Dodge\" INTERSECT SELECT t2.country FROM driver AS t1 JOIN country AS t2 ON t1.country  =  t2.country_id WHERE t1.Make  =  \"Chevrolet\"",
    "label": false,
    "reason": "Need return country.",
    "evidence": ""
  },
  {
    "question_id": 1671,
    "db_id": "institution_sports",
    "question": "In which years were more than one institution founded?",
    "predicted_sql": "SELECT Founded FROM institution GROUP BY Founded HAVING count(*) > 1",
    "gold_sql": "SELECT Founded ,  COUNT(*) FROM institution GROUP BY Founded HAVING COUNT(*)  >  1",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1688,
    "db_id": "warehouse_1",
    "question": "What is the average value of boxes for each warehouse?",
    "predicted_sql": "SELECT avg(value), warehouse FROM boxes GROUP BY warehouse",
    "gold_sql": "SELECT warehouse ,  avg(value) FROM boxes GROUP BY warehouse",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1704,
    "db_id": "warehouse_1",
    "question": "What are the different locations of warehouses?",
    "predicted_sql": "SELECT DISTINCT location FROM warehouses",
    "gold_sql": "SELECT count(DISTINCT LOCATION) FROM warehouses",
    "label": true,
    "reason": "Gold False. Ask for what, not count",
    "evidence": ""
  },
  {
    "question_id": 1709,
    "db_id": "warehouse_1",
    "question": "Find all contents present in warehouses located in Chicago and those located in New York.",
    "predicted_sql": "SELECT Boxes.Contents FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'Chicago' OR Warehouses.Location = 'New York'",
    "gold_sql": "SELECT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'Chicago' INTERSECT SELECT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'New York'",
    "label": true,
    "reason": "Gold False. Ask for a union, gold sql check for both.",
    "evidence": ""
  },
  {
    "question_id": 1711,
    "db_id": "warehouse_1",
    "question": "Find the type of contents that are not in the warehouses located at New York.",
    "predicted_sql": "SELECT DISTINCT Boxes.Contents FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location != 'New York'",
    "gold_sql": "SELECT CONTENTS FROM boxes EXCEPT SELECT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'New York'",
    "label": false,
    "reason": "Ask for contents not exist in New York. Predicted SQL return contents in warehouses outside New York.",
    "evidence": ""
  },
  {
    "question_id": 1717,
    "db_id": "warehouse_1",
    "question": "Find the location of the warehouses which store contents Rocks and Scissors.",
    "predicted_sql": "SELECT location FROM warehouses WHERE code IN ( SELECT warehouse FROM boxes WHERE contents IN ('Rocks', 'Scissors') )",
    "gold_sql": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' INTERSECT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
    "label": false,
    "reason": "Need to find warehouse has both Rocks and Scissors. Not either.",
    "evidence": ""
  },
  {
    "question_id": 1718,
    "db_id": "warehouse_1",
    "question": "What are the locations of warehouses in which boxes that contain Rocks and Scissors are kept?",
    "predicted_sql": "SELECT location FROM warehouses WHERE code IN (SELECT warehouse FROM boxes WHERE contents IN ('Rocks', 'Scissors'))",
    "gold_sql": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' INTERSECT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
    "label": false,
    "reason": "need And, not Or.",
    "evidence": ""
  },
  {
    "question_id": 1727,
    "db_id": "warehouse_1",
    "question": "Find the code of all boxes whose value is higher than the value of any boxes with Rocks as content.",
    "predicted_sql": "SELECT Code FROM Boxes WHERE Value > (SELECT MAX(Value) FROM Boxes WHERE Contents = 'Rocks')",
    "gold_sql": "SELECT code FROM boxes WHERE value  >  (SELECT min(value) FROM boxes WHERE CONTENTS  =  'Rocks')",
    "label": true,
    "reason": "Gold False. higher than any means higher than max.",
    "evidence": ""
  },
  {
    "question_id": 1732,
    "db_id": "warehouse_1",
    "question": "What is the total value of boxes kept in the warehouse with the greatest capacity?",
    "predicted_sql": "SELECT SUM(B.Value) AS TotalValue FROM Boxes AS B JOIN Warehouses AS W ON B.Warehouse = W.Code WHERE W.Capacity = (SELECT MAX(Capacity) FROM Warehouses)",
    "gold_sql": "SELECT sum(T1.value) FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code ORDER BY T2.capacity DESC LIMIT 1",
    "label": true,
    "reason": "Gold False. Need to find the max capacity of one ware house, not the sum.",
    "evidence": ""
  },
  {
    "question_id": 1735,
    "db_id": "warehouse_1",
    "question": "Find the total value and number of boxes for each content type.",
    "predicted_sql": "SELECT      Contents,      SUM(Value) AS TotalValue,      COUNT(*) AS NumberOfBoxes FROM      Boxes GROUP BY      Contents",
    "gold_sql": "SELECT sum(value) ,  count(*) ,  CONTENTS FROM boxes GROUP BY CONTENTS",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1741,
    "db_id": "warehouse_1",
    "question": "Find the value of the most expensive boxes saved in each warehouse location.",
    "predicted_sql": "SELECT      Warehouses.Location,      MAX(Boxes.Value) AS MostExpensiveBoxValue FROM      Boxes JOIN      Warehouses  ON      Boxes.Warehouse = Warehouses.Code GROUP BY      Warehouses.Location",
    "gold_sql": "SELECT max(T1.value) ,  T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code GROUP BY T2.location",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1742,
    "db_id": "warehouse_1",
    "question": "For each warehouse location, what is the value of the most expensive box?",
    "predicted_sql": "SELECT      Warehouses.Location,      MAX(Boxes.Value) AS MostExpensiveBoxValue FROM      Boxes JOIN      Warehouses  ON      Boxes.Warehouse = Warehouses.Code GROUP BY      Warehouses.Location",
    "gold_sql": "SELECT max(T1.value) ,  T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code GROUP BY T2.location",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1773,
    "db_id": "university_rank",
    "question": "Show all home conferences with average enrollment of universities above 2000.",
    "predicted_sql": "SELECT avg(enrollment), home_conference FROM university GROUP BY home_conference HAVING avg(enrollment) > 2000",
    "gold_sql": "SELECT home_conference FROM University GROUP BY home_conference HAVING avg(enrollment)  >  2000",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1779,
    "db_id": "university_rank",
    "question": "Show all majors and major ranks for the university with name Augustana College.",
    "predicted_sql": "SELECT major.major_name, major_ranking.rank FROM major_ranking JOIN major ON major_ranking.major_id = major.major_id JOIN university ON major_ranking.university_id = university.university_id WHERE university.university_name = 'Augustana College'",
    "gold_sql": "SELECT T1.rank ,  T3.major_name FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T2.university_name  =  'Augustana College'",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1797,
    "db_id": "university_rank",
    "question": "What is the total enrollment of universities with a overall rank 5 or below?",
    "predicted_sql": "SELECT SUM(T1.Enrollment) FROM university AS T1 JOIN overall_ranking AS T2 ON T1.University_ID = T2.University_ID WHERE T2.Rank <= 5",
    "gold_sql": "SELECT sum(enrollment) FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id WHERE T2.rank  >=  5",
    "label": true,
    "reason": "Gold False. As rank top 5, so rank should <= 5.",
    "evidence": ""
  },
  {
    "question_id": 1798,
    "db_id": "university_rank",
    "question": "What is the total number of students enrolled in an university with a rank of 5 or below?",
    "predicted_sql": "SELECT sum(enrollment) FROM university WHERE university_id IN (SELECT university_id FROM overall_ranking WHERE rank <= 5)",
    "gold_sql": "SELECT sum(enrollment) FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id WHERE T2.rank  >=  5",
    "label": true,
    "reason": "Gold False. Ask rank top 5, so need <= 5.",
    "evidence": ""
  },
  {
    "question_id": 1803,
    "db_id": "movie_2",
    "question": "Find the titles of movies that don’t have any rating.",
    "predicted_sql": "SELECT title FROM movies WHERE rating IS NULL",
    "gold_sql": "SELECT title FROM movies WHERE rating  =  'null'",
    "label": true,
    "reason": "Gold False. Column not string 'null' but NULL.",
    "evidence": ""
  },
  {
    "question_id": 1804,
    "db_id": "movie_2",
    "question": "What are the names of movies that do not have any ratings?",
    "predicted_sql": "SELECT Title FROM Movies WHERE Rating IS NULL",
    "gold_sql": "SELECT title FROM movies WHERE rating  =  'null'",
    "label": true,
    "reason": "Gold False. Column not string 'null'",
    "evidence": ""
  },
  {
    "question_id": 1821,
    "db_id": "movie_2",
    "question": "Find the name of the cinemas that are playing movies with either rating ‘G’ or rating ‘PG’.",
    "predicted_sql": "SELECT MovieTheaters.Name FROM Movies JOIN MovieTheaters ON Movies.Code = MovieTheaters.Movie WHERE Movies.Rating = 'G' OR Movies.Rating = 'PG'",
    "gold_sql": "SELECT title FROM movies WHERE rating  =  'G' OR rating  =  'PG'",
    "label": true,
    "reason": "Gold False. Ask for cinemas name. not movies name.",
    "evidence": ""
  },
  {
    "question_id": 1835,
    "db_id": "movie_2",
    "question": "Find the name of the movie that is played in the most number of theaters.",
    "predicted_sql": "SELECT      Movies.Title FROM      MovieTheaters JOIN      Movies  ON      MovieTheaters.Movie = Movies.Code GROUP BY      MovieTheaters.Movie ORDER BY      COUNT(*) DESC LIMIT 1",
    "gold_sql": "SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie GROUP BY T1.title ORDER BY count(*) DESC LIMIT 1",
    "label": false,
    "reason": "the Group By should by movie title.",
    "evidence": ""
  },
  {
    "question_id": 1837,
    "db_id": "movie_2",
    "question": "Find the number of movies in each rating.",
    "predicted_sql": "SELECT Rating, COUNT(*)  FROM Movies  GROUP BY Rating",
    "gold_sql": "SELECT count(*) ,  rating FROM movies GROUP BY rating",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1838,
    "db_id": "movie_2",
    "question": "How many movies exist for each rating?",
    "predicted_sql": "SELECT Rating, COUNT(*) FROM Movies GROUP BY Rating",
    "gold_sql": "SELECT count(*) ,  rating FROM movies GROUP BY rating",
    "label": true,
    "reason": "",
    "evidence": ""
  },
  {
    "question_id": 1840,
    "db_id": "movie_2",
    "question": "How many movies have a rating that is not null?",
    "predicted_sql": "SELECT count(*) FROM movies WHERE rating IS NOT NULL",
    "gold_sql": "SELECT count(*) ,  rating FROM movies WHERE rating != 'null' GROUP BY rating",
    "label": true,
    "reason": "Only as how many, not need to list by ratings.",
    "evidence": ""
  },
  {
    "question_id": 1841,
    "db_id": "movie_2",
    "question": "Find the name of theaters that has at least one movie playing.",
    "predicted_sql": "SELECT Name  FROM MovieTheaters  WHERE Movie IS NOT NULL",
    "gold_sql": "SELECT name FROM movietheaters GROUP BY name HAVING count(*)  >=  1",
    "label": false,
    "reason": "Not NULL != as least one.",
    "evidence": ""
  },
  {
    "question_id": 1843,
    "db_id": "movie_2",
    "question": "Select the name of all movie theaters that are not currently showing a movie.",
    "predicted_sql": "SELECT name FROM movietheaters WHERE movie IS NULL",
    "gold_sql": "SELECT DISTINCT name FROM MovieTheaters WHERE Movie  =  'null'",
    "label": true,
    "reason": "Gold False. Not string 'null'",
    "evidence": ""
  },
  {
    "question_id": 1844,
    "db_id": "movie_2",
    "question": "What are the names of all cinemas not showing any movies?",
    "predicted_sql": "SELECT Name FROM MovieTheaters WHERE Movie IS NULL",
    "gold_sql": "SELECT DISTINCT name FROM MovieTheaters WHERE Movie  =  'null'",
    "label": true,
    "reason": "Gold False. Not string 'null'",
    "evidence": ""
  },
  {
    "question_id": 1851,
    "db_id": "movie_2",
    "question": "Show all information of all unrated movies.",
    "predicted_sql": "SELECT * FROM movies WHERE rating IS NULL;",
    "gold_sql": "SELECT * FROM movies WHERE rating  =  'null'",
    "label": true,
    "reason": "Gold False. Not string 'null'",
    "evidence": ""
  },
  {
    "question_id": 1852,
    "db_id": "movie_2",
    "question": "What is all the information about the unrated movies?",
    "predicted_sql": "SELECT * FROM movies WHERE rating IS NULL",
    "gold_sql": "SELECT * FROM movies WHERE rating  =  'null'",
    "label": true,
    "reason": "Gold False. Not string 'null'",
    "evidence": ""
  },
  {
    "question_id": 1853,
    "db_id": "movie_2",
    "question": "Show the titles of movies not currently being shown in any theaters.",
    "predicted_sql": "SELECT Title FROM Movies WHERE Code NOT IN (     SELECT Movie     FROM MovieTheaters )",
    "gold_sql": "SELECT Title FROM Movies WHERE Code NOT IN (SELECT Movie FROM MovieTheaters WHERE Movie != 'null')",
    "label": true,
    "reason": "Gold False. not string 'null', sub query filter nothing.",
    "evidence": ""
  },
  {
    "question_id": 1854,
    "db_id": "movie_2",
    "question": "What are the names of the movies not being shown in any theaters?",
    "predicted_sql": "SELECT title FROM movies WHERE code NOT IN (SELECT movie FROM movietheaters)",
    "gold_sql": "SELECT Title FROM Movies WHERE Code NOT IN (SELECT Movie FROM MovieTheaters WHERE Movie != 'null')",
    "label": true,
    "reason": "Gold False. not string 'null', sub query filter nothing.",
    "evidence": ""
  },
  {
    "question_id": 1855,
    "db_id": "planet_1",
    "question": "Who receieved the heaviest package?",
    "predicted_sql": "SELECT Recipient FROM package ORDER BY Weight DESC LIMIT 1",
    "gold_sql": "SELECT T2.Name FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Recipient  =  T2.AccountNumber ORDER BY T1.Weight DESC LIMIT 1",
    "label": false,
    "reason": "Ask for who, need return name.",
    "evidence": ""
  },
  {
    "question_id": 1868,
    "db_id": "planet_1",
    "question": "What is the number of all packages that Leo Wong sent?",
    "predicted_sql": "SELECT COUNT(*)  FROM Client AS T1  JOIN Package AS T2  ON T1.AccountNumber = T2.Sender  WHERE T1.Name = \"Leo Wong\"",
    "gold_sql": "SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name  =  \"Leo Wong\";",
    "label": true,
    "reason": "Ask for number of all, can be treat as the quantity.",
    "evidence": ""
  },
  {
    "question_id": 1869,
    "db_id": "planet_1",
    "question": "List all package numbers received by Leo Wong ?",
    "predicted_sql": "SELECT Package.PackageNumber FROM Package JOIN Client ON Package.Recipient = Client.AccountNumber WHERE Client.Name = 'Leo Wong'",
    "gold_sql": "select t1.packagenumber from package as t1 join client as t2 on t1.recipient  =  t2.accountnumber where t2.name = \"leo wong\";",
    "label": true,
    "reason": "Gold False. Uppercase.",
    "evidence": ""
  },
  {
    "question_id": 1877,
    "db_id": "planet_1",
    "question": "What is the heaviest package sent by the clients which 'John' is part of their name? List package number and weight.",
    "predicted_sql": "SELECT Package.PackageNumber, Package.Weight FROM Package JOIN Client ON Package.Sender = Client.AccountNumber WHERE Client.Name LIKE '%John%' ORDER BY Package.Weight DESC LIMIT 1",
    "gold_sql": "SELECT T1.PackageNumber ,  max(T1.Weight) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name LIKE \"John\";",
    "label": true,
    "reason": "Gold False. Ask for the heaviest package's info. Not group by but max may return nothing.",
    "evidence": ""
  },
  {
    "question_id": 1878,
    "db_id": "planet_1",
    "question": "What is the package number and weight of the heaviest package that was sent by a client named John or something similar?",
    "predicted_sql": "SELECT packagenumber, weight FROM package INNER JOIN client ON package.sender = client.accountnumber WHERE LOWER(client.name) LIKE 'john%' ORDER BY package.weight DESC LIMIT 1;",
    "gold_sql": "SELECT T1.PackageNumber ,  max(T1.Weight) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name LIKE \"John\";",
    "label": true,
    "reason": "Gold False. Ask for the heaviest package's info. Not group by but max may return nothing.",
    "evidence": ""
  },
  {
    "question_id": 1881,
    "db_id": "planet_1",
    "question": "Who sent most number of packages? List client name and number of packages sent by that client.",
    "predicted_sql": "SELECT      Client.Name,      COUNT(*) AS PackageCount FROM      Client JOIN      Package  ON      Client.AccountNumber = Package.Sender GROUP BY      Client.Name ORDER BY      PackageCount DESC LIMIT 1",
    "gold_sql": "SELECT T2.Name ,  count(*) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber GROUP BY T1.Sender ORDER BY count(*) DESC LIMIT 1;",
    "label": false,
    "reason": "Group by name may merge different client with the same names. Use Sender as account is better.",
    "evidence": ""
  }
]