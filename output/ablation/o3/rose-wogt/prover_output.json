[
  {
    "question_id": 41,
    "result": {
      "expected_answer": "The list of school names (and optionally their reading scores) for exclusively virtual schools (Virtual='F') that rank within the top 5 reading-score performers inside their own county (ranking performed separately per County).",
      "sql_description": "Joins schools to satscores, keeps only Virtual='F', then orders the entire statewide set of virtual schools by AvgScrRead descending and returns the first 5 rows.",
      "reason": "Question requires top-5 ranking within each county, i.e., partitioned by County. The query instead applies a single statewide order and LIMIT 5, omitting many counties and including only the overall top 5. Missing the county partition anchor ⇒ incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 31,
    "result": {
      "expected_answer": "Return the eligible free meal rate (Free Meal Count (K-12) ÷ Enrollment (K-12)) for the schools that rank 10th and 11th highest in K-12 enrollment.",
      "sql_description": "Ranks all rows in frpm by Enrollment (K-12) in descending order, skips the first nine rows, and selects the next two (10th and 11th). For each, it outputs School Name and the ratio Free Meal Count / Enrollment as eligible_free_rate.",
      "reason": "Uses correct formula, orders by the right metric, applies OFFSET 9 LIMIT 2 to pick exactly the 10th and 11th entries; thus meets all stated requirements. Ambiguity about academic year is acceptable because question doesn’t specify a year and the table stores data at school-year granularity.",
      "verdict": true,
      "evidence": "sql_result shows two rows with columns School Name and eligible_free_rate."
    }
  },
  {
    "question_id": 67,
    "result": {
      "expected_answer": "The question seeks a single number: how many Community College District entities were closed in 1989 in the city of San Francisco.",
      "sql_description": "Counts all records in schools where City is 'San Francisco', DOCType is 'Community College District', and the year portion of ClosedDate is 1989.",
      "reason": "The query directly implements the required city, district-type, and closure-year constraints and returns the count, which is the requested measure of total closures.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 2 (row 0), indicating two such closures."
    }
  },
  {
    "question_id": 51,
    "result": {
      "expected_answer": "The mailing street address together with the name of the school whose AvgScrRead value is the lowest among all schools.",
      "sql_description": "Joins satscores and schools, sorts every satscores row (any rtype) by AvgScrRead ascending and returns the MailStreet and School columns from the first row.",
      "reason": "1) It does not restrict to rows that represent schools; the minimum could come from a district/county‐level record, violating the school anchor. 2) The sample result already shows the School column as NULL, so even when a row is returned it may not supply the required school name. Hence the query cannot be relied on to answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 20,
    "result": {
      "expected_answer": "The number of schools located in Amador County whose lowest grade offered is 9 and highest grade offered is 12.",
      "sql_description": "Counts the rows in frpm where County Name = 'Amador', Low Grade = '9', and High Grade = '12'; returns that count (3).",
      "reason": "Query applies the required county and grade anchors and returns the count requested. Row-level counting is adequate because in this dataset each CDSCode appears at most once, so COUNT(CDSCode) equals the number of schools.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(CDSCode)=3, one column matching the requested figure."
    }
  },
  {
    "question_id": 0,
    "result": {
      "expected_answer": "A single numeric value: the maximum ratio of Free Meal Count (K-12) to Enrollment (K-12) among all Alameda County schools (any academic year).",
      "sql_description": "For each record in frpm joined to its school, it computes Free Meal Count (K-12) / Enrollment (K-12), restricts to rows whose school is in Alameda County, orders the ratios descending and returns the top one.",
      "reason": "Query applies correct formula, limits scope to Alameda County via schools.County, finds the highest per-school eligible free rate, matching the question’s requirement. No required anchors are missing or contradicted.",
      "verdict": true,
      "evidence": "Result set column: eligible_free_rate (no rows due to data), but logic aligns with requirement."
    }
  },
  {
    "question_id": 126,
    "result": {
      "expected_answer": "Percentage = (number of accounts opened in 1993 that are in district 'Decin') / (total number of accounts opened in 1993 across all districts) * 100",
      "sql_description": "Filters only accounts from Decin, then divides the count of Decin accounts opened in 1993 by the count of all Decin accounts, returning the share of Decin accounts that were opened in 1993.",
      "reason": "Denominator should be all 1993 accounts, not all Decin accounts. Thus the computed percentage answers a different question.",
      "verdict": false
    }
  },
  {
    "question_id": 43,
    "result": {
      "expected_answer": "Return the average math SAT score (AvgScrMath) and the county name of the single school whose combined score (AvgScrMath + AvgScrRead + AvgScrWrite) is the lowest among all schools.",
      "sql_description": "Joins satscores with schools, orders rows by the sum of AvgScrMath, AvgScrRead, and AvgScrWrite in ascending order (equivalent ranking to lowest average), and outputs the AvgScrMath and County of the first (lowest-scoring) school.",
      "reason": "All required anchors are met: it considers every school, ranks by overall score (sum is monotonic with average), and returns exactly the math average and county for the lowest-scoring school. No extraneous constraints are introduced.",
      "verdict": true,
      "evidence": "sql_result shows columns AvgScrMath and County with one row (AvgScrMath=None, County='Fresno'), matching the requested output structure."
    }
  },
  {
    "question_id": 30,
    "result": {
      "expected_answer": "Names of the 5 distinct cities whose total (or at least city-level) K-12 enrollment is the smallest across all cities; i.e., rank cities by enrollment for grades 1-12 and output the five with the lowest numbers.",
      "sql_description": "Joins the frpm school-level enrollment table to schools, orders individual school rows by Enrollment (K-12) ascending, takes the first 5 rows and returns their City values (without DISTINCT or city-level aggregation).",
      "reason": "The query ranks individual schools, not cities: it neither aggregates enrollment by city nor ensures distinct city names. Consequently it may list the same city multiple times and can miss cities that have low total enrollment but no school in the five lowest-enrollment rows. Required anchor \"city-level ranking\" is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 141,
    "result": {
      "expected_answer": "A list of district names whose accounts recorded any transaction over $10,000 during the year 1997.",
      "sql_description": "Joins trans → account → district, filters rows where trans.amount > 10000 and the transaction year extracted from trans.date is 1997, then returns DISTINCT district.A2 (district names).",
      "reason": "All explicit anchors are satisfied: amount strictly greater than 10,000 and year 1997; output is district names with duplicates removed. No extraneous constraints added.",
      "verdict": true,
      "evidence": "sql_result shows A2 column with 20 district names (e.g., 'Hl.m. Praha', 'Kolin', ... 'Strakonice'), confirming expected output shape."
    }
  },
  {
    "question_id": 233,
    "result": {
      "expected_answer": "The alphabetical first two bond_id values associated with molecule TR006.",
      "sql_description": "Fetches all bonds where molecule_id = 'TR006', orders them alphabetically by bond_id ascending, and returns the first two bond_id values.",
      "reason": "Query applies the TR006 molecule filter, orders alphabetically, and limits to two rows, satisfying the request for the top two bonds in alphabetical order.",
      "verdict": true,
      "evidence": "sql_result shows two rows: bond_id column values TR006_11_12 and TR006_11_13."
    }
  },
  {
    "question_id": 112,
    "result": {
      "expected_answer": "The name of the district (column district.A2) in which the female client born on 1976-01-29 opened her account.",
      "sql_description": "Joins client → disp → account → district, filters client rows where gender = 'F' and birth_date = '1976-01-29', then returns the distinct district name(s) (A2) of the linked account(s).",
      "reason": "Query respects all explicit anchors (gender = 'F', birth_date = 1976-01-29) and outputs the district name tied to the client’s account; this matches the question’s request.",
      "verdict": true,
      "evidence": "sql_result shows one row with A2 = 'Tachov'."
    }
  },
  {
    "question_id": 77,
    "result": {
      "expected_answer": "All schools in Los Angeles County whose GSserved value is exactly \"K-9\", together with each school’s Percent (%) Eligible FRPM (Ages 5-17).",
      "sql_description": "Joins schools with frpm on CDSCode, filters to rows where schools.GSserved = 'K-9' and schools.County = 'Los Angeles', then returns School and the stored Percent (%) Eligible FRPM (Ages 5-17).",
      "reason": "Query applies both required anchors (grade span K-9 and Los Angeles County) and returns the requested fields. Using the pre-computed percentage column is acceptable. Possible multiple years are not constrained by the question, so including them is permissible.",
      "verdict": true,
      "evidence": "Rows returned: [School, Percent] e.g. White Oak Elementary (0.037559), The Accelerated (0.976389)"
    }
  },
  {
    "question_id": 80,
    "result": {
      "expected_answer": "Return the school type (SOCType), the school name, and its latitude for whichever school(s) has the maximum latitude value in the table—that is, the northern-most school.",
      "sql_description": "Selects SOCType, School, Latitude from schools, orders rows by Latitude descending, and keeps only the first row, thereby giving the type, name, and latitude of the single school with the highest latitude.",
      "reason": "Query explicitly targets the maximum latitude via ORDER BY Latitude DESC LIMIT 1 and outputs the requested columns, satisfying the question’s requirement for school type, name, and latitude of the northern-most school. Returning a single row is acceptable for a singular superlative.",
      "verdict": true,
      "evidence": "Row0: SOCType='High Schools (Public)', School='Leggett Valley High', Latitude=44.219305"
    }
  },
  {
    "question_id": 124,
    "result": {
      "expected_answer": "For every loan whose duration equals 60 months, return its loan_id together with the district it belongs to and that district’s average salary.",
      "sql_description": "Joins loan → account → district, keeps rows where loan.duration = 60, and outputs loan.loan_id, district.district_id (the district identifier) and district.A11 (average salary).",
      "reason": "All required anchors are satisfied: duration = 60 filter, loan_id reported, a district indicator (district_id) supplied, and average salary (A11) included. Using district_id is a reasonable interpretation of the term “district.”",
      "verdict": true,
      "evidence": "sql_result shows columns loan_id, district_id, A11 with 20 rows, e.g. (4967, 20, 8547)."
    }
  },
  {
    "question_id": 133,
    "result": {
      "expected_answer": "For the district record(s) with the maximum value of A13 (unemployment rate 1996), return both the branch location (district_id) and the district name (A2).",
      "sql_description": "Finds rows whose unemployment rate 1996 (A13) equals the maximum A13, but returns only the district name (A2).",
      "reason": "Required anchor \"branch location\" (district_id) is omitted from the SELECT list, so the query does not provide all requested information.",
      "verdict": false
    }
  },
  {
    "question_id": 173,
    "result": {
      "expected_answer": "1) The number of transactions on account_id = 3 whose purpose (k_symbol) corresponds to requesting an account statement (in the data this purpose is coded in k_symbol, e.g. 'SLUZBY'). 2) The k_symbol (purpose/aim) associated with the debit transaction(s) on account_id = 3 where the total debited amount is 3539.",
      "sql_description": "Returns two separate counts: A) count of rows for account 3 with k_symbol = 'statement'; B) count of rows for account 3 with amount = 3539 and k_symbol = 'payment'.",
      "reason": "First count uses a literal value 'statement' instead of the coded purpose ('SLUZBY'); second part should return the purpose (k_symbol) for the 3539 debit but instead returns a count and also hard-codes k_symbol = 'payment'. Required anchors (correct k_symbol mapping and returning the aim, not a count) are missing or contradicted.",
      "verdict": false
    }
  },
  {
    "question_id": 177,
    "result": {
      "expected_answer": "Return the account balance of client_id 4 after transaction 851 (i.e., the balance recorded for that transaction or immediately after it) together with the owner’s gender (M/F). A single numeric balance value plus gender.",
      "sql_description": "Joins client 4’s accounts to all their transactions having trans_id > 851 and returns the SUM of the balance column over those rows along with the client’s gender.",
      "reason": "The query aggregates balances from multiple later transactions instead of selecting the balance following transaction 851. Summing per-transaction balances inflates the amount and does not represent the required single post-transaction balance. Gender part is fine, but the monetary value is incorrect, so overall answer is wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 218,
    "result": {
      "expected_answer": "A single percentage value: among molecules with label '+', what proportion (in %) have zero fluorine atoms.",
      "sql_description": "Gets all carcinogenic molecules, counts distinct ones that contain at least one atom where element='f', divides by total distinct carcinogenic molecules, converts to a % and subtracts from 100, yielding the % of carcinogenic molecules without fluorine.",
      "reason": "All required anchors are present: filters label='+', uses element='f', works on distinct molecule_ids, and computes share of molecules lacking fluorine. Logic matches the question.",
      "verdict": true,
      "evidence": "percentage column row0 = 99.342105"
    }
  },
  {
    "question_id": 236,
    "result": {
      "expected_answer": "Return the bond type and the two atom ids that form the bond whose bond_id is 'TR001_6_9'.",
      "sql_description": "Looks up rows in connected with bond_id = 'TR001_6_9', joins to bond to fetch bond_type, and outputs bond_type together with atom_id and atom_id2.",
      "reason": "Query applies the required bond_id filter, retrieves the bond_type from bond, and lists both atoms involved. Duplicate reverse-order row is harmless for the asked information, so requirements are met.",
      "verdict": true,
      "evidence": "Rows: (bond_type='-', atom_id='TR001_6', atom_id2='TR001_9') and reverse order duplicate."
    }
  },
  {
    "question_id": 252,
    "result": {
      "expected_answer": "A list of atom_id values for atoms that are bonded to any atom whose element value is 'pb' (lead). All atoms bonded to every lead atom, regardless of which side of the bond record the lead atom appears, must be included.",
      "sql_description": "Returns atom_id2 for each record in connected where atom_id belongs to a lead atom (element = 'pb'). It ignores cases where the lead atom could appear in the atom_id2 column.",
      "reason": "The query enforces the lead atom anchor but only for bonds recorded with the lead atom in connected.atom_id. If a bond is stored with the lead atom in connected.atom_id2, those partner atoms would be missed, so the result may be incomplete. Required anchor (lead atom regardless of position in bond) not fully covered.",
      "verdict": false
    }
  },
  {
    "question_id": 309,
    "result": {
      "expected_answer": "For molecule TR346: the IDs of all atoms that belong to it together with the number of different bond types that occur in TR346.",
      "sql_description": "Retrieves every atom whose molecule_id is 'TR346' (using atom table), joins to its incident bonds via connected and bond, and for each atom outputs the count of DISTINCT bond_type values found among those bonds.",
      "reason": "Meets both anchors: 1) atom ids are restricted to molecule TR346; 2) COUNT(DISTINCT bond.bond_type) gives the variety of bond types present in TR346. Although the count is calculated per-atom, it still reports the molecule’s bond-type diversity (same value for every atom) and therefore answers the ‘how many bond type’ part. No required constraint is missed.",
      "verdict": true,
      "evidence": "Result shows atom_id column (e.g., TR346_1 … TR346_8) and bond_type_count column with value 1 for each, confirming 8 atoms and 1 bond type."
    }
  },
  {
    "question_id": 275,
    "result": {
      "expected_answer": "List of molecule_id values for bonds whose bond_type represents a double bond (i.e., bond_type = '='); any molecule that possesses at least one double bond should appear.",
      "sql_description": "Selects molecule_id from bond where bond_type equals '='; returns one row per matching bond, so molecules with multiple double bonds may appear multiple times.",
      "reason": "Query applies the required anchor bond_type='=' and retrieves the requested molecule_id. Duplication is permissible because the question does not explicitly ask for uniqueness.",
      "verdict": true,
      "evidence": "sql_result shows column molecule_id with rows such as TR001, TR002, TR004, TR005 (many times), TR006 (many times), TR007, confirming retrieval of molecule IDs with double bonds."
    }
  },
  {
    "question_id": 376,
    "result": {
      "expected_answer": "List of layout type(s) for every card whose keywords include \"Flying\".",
      "sql_description": "Fetches the layout column from cards where the keywords string contains the substring 'Flying'.",
      "reason": "The query filters on the required anchor (cards whose keywords include Flying) and returns the requested attribute (layout). The question does not demand duplicate removal, so returning one row per matching card is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows column layout with multiple rows, all value 'normal', matching the requested information."
    }
  },
  {
    "question_id": 174,
    "result": {
      "expected_answer": "The birth year of the account owner with ID 130.",
      "sql_description": "Selects the year component of birth_date for the client whose client_id is 130 from the client table.",
      "reason": "Matches owner ID anchor (130) and returns the birth year only; satisfies question.",
      "verdict": true,
      "evidence": "Result column strftime('%Y', T1.birth_date) shows 1942 for the single row."
    }
  },
  {
    "question_id": 257,
    "result": {
      "expected_answer": "Return all values from connected.atom_id2 where the connected row involves a sulfur atom (element = 's'), i.e., for every sulfur atom that appears as the first atom in a bond, output the partner atom’s id2.",
      "sql_description": "Joins connected with atom on connected.atom_id = atom.atom_id, filters atoms with element 's', and outputs the associated connected.atom_id2.",
      "reason": "Interpreting the request as: ‘for atoms whose element is sulfur, list the atom_id2 they are bonded to’. The query applies the sulfur filter on the atom table and returns the corresponding atom_id2, satisfying this reading. All explicit anchors (element = 's', returning atom_id2) are present.",
      "verdict": true,
      "evidence": "Result shows a single column atom_id2 (e.g., TR004_2, TR018_13 …) coming from connected, confirming the query performed as described."
    }
  },
  {
    "question_id": 344,
    "result": {
      "expected_answer": "Names of cards whose printing rarity is 'mythic' and whose legality entry shows status 'Banned' in the gladiator format.",
      "sql_description": "Joins cards to legalities on uuid, then filters for cards with rarity = 'mythic' and legalities rows where format = 'gladiator' and status = 'Banned', returning the card name column.",
      "reason": "All required anchors—rarity 'mythic', status 'Banned', format 'gladiator'—are explicitly enforced. Although duplicates may appear because different printings share the same name, the question only asks to list the cards and does not demand DISTINCT, so the query suffices.",
      "verdict": true,
      "evidence": "sql_result shows names column with banned mythic cards e.g., rows: 0-4 'Oko, Thief of Crowns', 'Nexus of Fate'."
    }
  },
  {
    "question_id": 453,
    "result": {
      "expected_answer": "Return the card's unconverted mana cost (manaCost field) for \"Ancestor's Chosen\".",
      "sql_description": "Fetches the numeric convertedManaCost for rows whose name equals \"Ancestor's Chosen\".",
      "reason": "Uses convertedManaCost instead of manaCost, so it answers a different attribute than the requested unconverted mana cost.",
      "verdict": false
    }
  },
  {
    "question_id": 281,
    "result": {
      "expected_answer": "A count for each chemical element indicating how many carcinogenic molecules have that element at their 4th atom position.",
      "sql_description": "Retrieves atoms whose 7th character in atom_id is '4' (interpreted as the 4th atom) and belong to molecules labelled '+', then groups by element and counts them.",
      "reason": "Meets all anchors: filters only carcinogenic molecules (label '+'), isolates 4th atoms via SUBSTRING(...,'4'), and tallies occurrences per element. Counting rows is appropriate since there is normally one 4th-atom row per molecule; even if multiple exist, it still reflects atom-level tally, a reasonable interpretation of ‘tally’.",
      "verdict": true,
      "evidence": "sql_result shows columns element, COUNT(*) with rows such as br 6, c 145, … confirming grouped counts."
    }
  },
  {
    "question_id": 597,
    "result": {
      "expected_answer": "A single number: how many distinct users are located in India and possess a badge named \"Teacher\".",
      "sql_description": "Joins users with badges, filters rows where badge name is 'Teacher' and user location is 'India', then counts DISTINCT user IDs.",
      "reason": "All required anchors (badge name = Teacher, user location = India) are applied and duplicates per user are removed; thus the returned count answers the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT u.Id) = 18"
    }
  },
  {
    "question_id": 430,
    "result": {
      "expected_answer": "Two set records (id and name) that 1) belong to block 'Shadowmoor', 2) have at least one Italian-language card, returned in alphabetical order by set name; only the first two such sets should be listed.",
      "sql_description": "Joins set_translations to sets, keeps rows where language='Italian' and block='Shadowmoor', orders by sets.name ascending, and returns the first two rows (id, name).",
      "reason": "All required anchors are present: block filter, Italian-language existence via inner join, alphabetical ordering, limit to two results, and the selected columns include the set id. Possible duplicate rows are avoided in the shown result, so the query delivers the requested information.",
      "verdict": true,
      "evidence": "sql_result rows: (0) id=101 name='Eventide'; (1) id=485 name='Shadowmoor'"
    }
  },
  {
    "question_id": 264,
    "result": {
      "expected_answer": "For each molecule id TR000, TR001 and TR002, return its label (+ for carcinogenic, - for non-carcinogenic). Result should pair every id with its label.",
      "sql_description": "Returns only the label column for rows whose molecule_id is in the three specified ids, giving three label values but omitting the molecule_id column.",
      "reason": "Question requires labels tied to each specific molecule id; predicted query drops the molecule_id anchor, so the mapping of label to id is lost and the answer is ambiguous.",
      "verdict": false
    }
  },
  {
    "question_id": 220,
    "result": {
      "expected_answer": "The alphabetically first three distinct element symbols present in molecule TR000.",
      "sql_description": "Retrieves element values for all atoms of molecule TR000, orders them alphabetically and returns the first three rows, without removing duplicates.",
      "reason": "Question implies three separate elements. Without DISTINCT the query can return duplicate symbols and fail to include a third unique element, so it does not reliably answer the request.",
      "verdict": false
    }
  },
  {
    "question_id": 470,
    "result": {
      "expected_answer": "The release date(s) of the set(s) that include the card named \"Ancestor's Chosen\".",
      "sql_description": "Joins cards to sets on set code, filters rows where cards.name = 'Ancestor''s Chosen', and returns the releaseDate of each corresponding set.",
      "reason": "Covers required anchor (card name) and returns the desired field (releaseDate) from the related set. Multiple rows are acceptable because the question does not specify one particular printing; duplicates do not alter correctness.",
      "verdict": true,
      "evidence": "sql_result shows releaseDate column with values: rows 0-1 2007-07-13, row 2 2002-05-27, row 3 2018-12-07."
    }
  },
  {
    "question_id": 304,
    "result": {
      "expected_answer": "All molecules marked carcinogenic (label '+') together with each element found in their atoms, one row per molecule–element combination.",
      "sql_description": "Selects from molecule joined to atom, keeps only rows where molecule.label = '+', and outputs distinct (molecule_id, element) pairs via GROUP BY.",
      "reason": "Uses the carcinogenic anchor, links to atoms to get elements, eliminates duplicates; thus returns exactly the requested molecule–element list.",
      "verdict": true,
      "evidence": "Result shows columns molecule_id and element (e.g., TR000–c, TR000–cl, …), matching the required format."
    }
  },
  {
    "question_id": 425,
    "result": {
      "expected_answer": "All card numbers whose side field is NULL (indicating no multiple faces) and whose subtypes list contains both \"Angel\" and \"Wizard\".",
      "sql_description": "Returns the number column from cards where side IS NULL and subtypes contains the substrings 'Angel' and 'Wizard', ensuring both subtype conditions are met.",
      "reason": "Query enforces the required side=NULL anchor and simultaneously checks for both Angel and Wizard in subtypes; this aligns with the question’s constraints.",
      "verdict": true,
      "evidence": "sql_result shows numbers (97, 226p, 226s, 226, 368) returned in column 'number'."
    }
  },
  {
    "question_id": 751,
    "result": {
      "expected_answer": "A list (≥5 items) of superpower names that belong to superheroes whose gender is Male.",
      "sql_description": "Joins superhero → gender to keep rows with gender='Male', then joins hero_power and superpower to collect the distinct power_name values, finally returns up to 5 of those names.",
      "reason": "All required anchors are satisfied: filters for Male heroes, outputs power_name, and returns 5 distinct results, meeting the 'at least five' minimum.",
      "verdict": true,
      "evidence": "sql_result power_name column shows 5 rows (Agility, Super Strength, Stamina, Super Speed, Accelerated Healing)."
    }
  },
  {
    "question_id": 447,
    "result": {
      "expected_answer": "List of setCode (code) values for all sets whose expansion type is 'commander'.",
      "sql_description": "Retrieves the code column from the sets table filtering rows where type = 'commander'.",
      "reason": "The query applies the required commander type filter and returns only the code field, matching the question’s request.",
      "verdict": true,
      "evidence": "sql_result shows 14 rows with column 'code', e.g., C13, C14 … ZNC (row indices 0-13)."
    }
  },
  {
    "question_id": 405,
    "result": {
      "expected_answer": "The number of distinct sets (one per set code) whose block is 'Commander' and that have a translation in the language exactly labelled 'Portuguese (Brasil)'.",
      "sql_description": "Counts every row produced by joining sets to set_translations where sets.block = 'Commander' and language = 'Portuguese (Brazil)'. No DISTINCT on set codes.",
      "reason": "1) Anchor mismatch: uses language 'Portuguese (Brazil)', not the required 'Portuguese (Brasil)'.\n2) Counts rows, not distinct sets, so may over-count when multiple Portuguese rows exist for the same set. Therefore does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 465,
    "result": {
      "expected_answer": "Return yes/no (or boolean/1-0) indicating whether any printing of the card named \"Ancestor's Chosen\" has a record in Korean language.",
      "sql_description": "Joins cards with foreign_data on uuid and checks for rows where cards.name = 'Ancestor''s Chosen' and foreign_data.language = 'Korean'; returns true if at least one such row exists, false otherwise.",
      "reason": "Query uses correct tables and filters on both required anchors (card name and Korean language). Resulting boolean correctly answers if a Korean version exists.",
      "verdict": true,
      "evidence": "Result column \"COUNT(*) > 0\" is 0, meaning no Korean version found."
    }
  },
  {
    "question_id": 507,
    "result": {
      "expected_answer": "A single numeric value: the percentage (0–100) of cards that have a Portuguese (Brazil) translation whose isOnlineOnly flag equals 1, relative to all cards with a Portuguese (Brazil) translation.",
      "sql_description": "Joins foreign_data and cards on uuid, keeps rows where language = 'Portuguese (Brazil)', counts how many of those rows have isOnlineOnly = 1, divides by total count of such rows, and multiplies by 100 to output that percentage.",
      "reason": "All required anchors are present: language filter correctly applied and online-only condition counted; the arithmetic produces the requested percentage. Duplicate handling is ambiguous in the question, and counting rows rather than distinct uuid is a reasonable interpretation because each row represents a card printing; ratio remains valid even if duplicates exist.",
      "verdict": true,
      "evidence": "sql_result contains one row with column percentage (value 0.0 in this database snapshot)."
    }
  },
  {
    "question_id": 480,
    "result": {
      "expected_answer": "One or more strings containing the Italian flavor text for the card named \"Ancestor's Chosen.\"",
      "sql_description": "Joins cards to foreign_data on uuid, keeps rows where card name is 'Ancestor's Chosen' and language is 'Italian', then returns the flavorText column from foreign_data.",
      "reason": "Both required anchors—card name and Italian language—are explicitly filtered. The query outputs the requested flavorText values, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows column flavorText with two Italian lines (rows 0-1)."
    }
  },
  {
    "question_id": 505,
    "result": {
      "expected_answer": "Return the Simplified Chinese (language = 'Chinese Simplified') translation of the Magic set whose English name is 'Mirrodin'.",
      "sql_description": "Joins sets with set_translations via set code, filters for T1.name = 'Mirrodin' and T2.language = 'Chinese Simplified', and outputs T2.translation.",
      "reason": "All explicit anchors—set name 'Mirrodin' and language 'Chinese Simplified'—are satisfied. The selected column is the translation, matching the requested content.",
      "verdict": true,
      "evidence": "translation column shows one row: 秘罗地 (row 0)."
    }
  },
  {
    "question_id": 646,
    "result": {
      "expected_answer": "For every comment with Score > 60 (positive comments), return the title of the post that received the comment together with the display name of the user who wrote that comment.",
      "sql_description": "Joins comments with their posts, filters to comments where Score > 60, and selects the post Title and the comment's UserDisplayName.",
      "reason": "All explicit anchors are satisfied: the filter ensures only positive comments (Score > 60); the output includes the post title and the commenter’s display name. No additional constraints are missed.",
      "verdict": true,
      "evidence": "Result columns: Title, UserDisplayName (e.g., row0: Detecting a given face in a database of facial..., Hans Westerbeek)."
    }
  },
  {
    "question_id": 606,
    "result": {
      "expected_answer": "All badge names earned at the exact timestamp 2010-07-19 19:39:08.",
      "sql_description": "Fetches distinct Name values from badges where Date equals '2010-07-19 19:39:08.0'.",
      "reason": "Query applies the required timestamp filter and outputs the badge names, fulfilling the question. DISTINCT is harmless.",
      "verdict": true,
      "evidence": "Returned Name column with 3 rows: Student, Editor, Organizer"
    }
  },
  {
    "question_id": 451,
    "result": {
      "expected_answer": "The number of cards whose availability list contains \"paper\" and whose hand field equals the positive value 3 (hand = '3').",
      "sql_description": "Counts rows in cards where availability contains the substring \"paper\" and the hand field starts with a plus sign (values like '+1', '+3', etc.).",
      "reason": "Question/evidence explicitly anchors positive hand size to hand = '3'. Predicted SQL filters on hand LIKE '+%', which excludes records stored as '3' and includes any other '+X' values, so the required hand anchor is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 860,
    "result": {
      "expected_answer": "Nationality of the driver whose Q2 qualifying time was 0:01:40 in race 355.",
      "sql_description": "Looks up qualifying rows with raceId = 355 and q2 = '0:01:40', joins to drivers, returns the driver’s nationality.",
      "reason": "Covers both required anchors (race 355, Q2 time 0:01:40) and selects the requested field; logic matches question.",
      "verdict": true,
      "evidence": "sql_result shows column [nationality] (0 rows) – query would output that nationality if it exists."
    }
  },
  {
    "question_id": 570,
    "result": {
      "expected_answer": "The name(s) of every badge earned by the user whose DisplayName is \"DatEpicCoderGuyWhoPrograms\".",
      "sql_description": "Joins badges to users, keeps rows where users.DisplayName = 'DatEpicCoderGuyWhoPrograms', and returns DISTINCT badges.Name.",
      "reason": "Includes required anchor (specific DisplayName) and returns the badge name field; thus answers which badge(s) the user holds. Singular wording permits multiple results, so returning all distinct badge names is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows column Name with value \"Autobiographer\" in row 0, matching expected badge name output."
    }
  },
  {
    "question_id": 508,
    "result": {
      "expected_answer": "The set of availability printing types (e.g., paper, mtgo, etc.) for cards whose artist is Aleksi Briclot and which have no text box (isTextless = 1).",
      "sql_description": "Returns the availability field for every card where artist = 'Aleksi Briclot' and isTextless = 1; duplicates are not removed.",
      "reason": "Query applies both required filters (artist, isTextless) and outputs the requested availability attribute. Extra duplicates do not violate the question, which only asks what types are available, and the distinct values are derivable from the result.",
      "verdict": true,
      "evidence": "sql_result shows availability column with values: row0 paper, row1 paper, row2 mtgo, row3 mtgo – yielding distinct types paper, mtgo."
    }
  },
  {
    "question_id": 761,
    "result": {
      "expected_answer": "Superhero_name values for male superheroes whose weight_kg is greater than 0.79 times the overall average weight_kg of all superheroes.",
      "sql_description": "Computes the overall average weight of all superheroes, multiplies by 0.79, then returns superhero_name for rows where gender='Male' and weight_kg exceeds that threshold.",
      "reason": "Query enforces gender='Male' and the weight > AVG(weight)*0.79 condition exactly as required; no anchors are missing or contradicted.",
      "verdict": true,
      "evidence": "sql_result shows column superhero_name with example row 0: 'King Kong'."
    }
  },
  {
    "question_id": 762,
    "result": {
      "expected_answer": "Name of the superpower that is possessed by the greatest number of superheroes (i.e., the power with the highest hero count).",
      "sql_description": "Joins hero_power with superpower, counts how many times each power_id appears (number of heroes who have it), orders powers by that count descending, and returns the top power_name (LIMIT 1).",
      "reason": "Query correctly implements MAX(COUNT(power_name)) logic; counts heroes per power, orders by count DESC, takes first. Meets all anchors.",
      "verdict": true,
      "evidence": "sql_result shows power_name column with one row: 'Super Strength', indicating the identified most common power."
    }
  },
  {
    "question_id": 738,
    "result": {
      "expected_answer": "A list of superheroes (e.g., their names or IDs) whose Durability attribute value is below 50.",
      "sql_description": "Returns a single number: the count of superheroes whose Durability attribute is below 50.",
      "reason": "Question asks for the superheroes themselves, not the number of such heroes. Query aggregates instead of listing the superheroes.",
      "verdict": false
    }
  },
  {
    "question_id": 894,
    "result": {
      "expected_answer": "Return the minimum lap time (in milliseconds) ever recorded and identify the driver (forename, surname) and the race (name) where that lap was set.",
      "sql_description": "Joins lapTimes with drivers and races, filters out NULL lap times, sorts by milliseconds ascending, and returns the first row (smallest milliseconds) along with the driver’s forename, surname, race name, and the lap time.",
      "reason": "Query correctly targets the global minimum lap time, retrieves one corresponding driver and race, satisfying the singular phrasing of the question. All required anchors—min(milliseconds), driver name, race name—are met.",
      "verdict": true,
      "evidence": "Columns returned: forename, surname, name, milliseconds; first row shows Lewis Hamilton | Austrian Grand Prix | 67411"
    }
  },
  {
    "question_id": 670,
    "result": {
      "expected_answer": "The datetime of the first (earliest) post made by the user(s) whose age is the minimum in the users table.",
      "sql_description": "Joins users with posts, filters to users whose Age equals the global minimum Age, then returns MIN(posts.CreaionDate), i.e., the earliest post date among those users.",
      "reason": "Satisfies both anchors: (1) youngest user via u.Age = (SELECT MIN(Age)), (2) first post via MIN(CreaionDate). If several users tie for youngest, choosing the earliest first post among them is a reasonable singular answer.",
      "verdict": true,
      "evidence": "sql_result shows one column FirstPostDate with value 2010-08-09 00:37:45.0 (row 0)."
    }
  },
  {
    "question_id": 853,
    "result": {
      "expected_answer": "Names of all races that took place on circuits located in Spain.",
      "sql_description": "Joins circuits with races, keeps rows where the circuit's country is 'Spain', returns the races.name column.",
      "reason": "The query applies the required Spain country filter on circuits and outputs the corresponding race names, satisfying the question. Presence of duplicates is acceptable because uniqueness was not demanded.",
      "verdict": true,
      "evidence": "sql_result shows races.name column with values such as 'Spanish Grand Prix' and 'European Grand Prix', confirming retrieval of race names related to Spanish circuits."
    }
  },
  {
    "question_id": 719,
    "result": {
      "expected_answer": "A single integer: the number of distinct superheroes who both possess the power named 'Super Strength' and have height_cm > 200.",
      "sql_description": "Counts distinct superhero ids after joining superheroes to hero_power and superpower, filtering for power_name = 'Super Strength' and height_cm > 200.",
      "reason": "All required anchors are present: power_name filter, height_cm > 200, distinct heroes. Query returns one integer, matching the question.",
      "verdict": true,
      "evidence": "sql_result column COUNT(DISTINCT T1.id) shows 56."
    }
  },
  {
    "question_id": 718,
    "result": {
      "expected_answer": "A single integer: the number of distinct superheroes who possess the power named \"Super Strength\".",
      "sql_description": "Joins superpower with hero_power filtered to power_name = 'Super Strength' and returns COUNT(*) of the matching rows, i.e., the number of hero-power records for that power.",
      "reason": "The question asks for the count of superheroes, requiring a count of distinct hero_id values. The query counts rows, not DISTINCT hero_id, so duplicate records (if any) would inflate the result. Missing the distinct-hero anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 865,
    "result": {
      "expected_answer": "The driver(s) with the earliest date of birth (i.e., oldest) among those who recorded a finish time (time IS NOT NULL) in race 592.",
      "sql_description": "Joins drivers with results, keeps rows where raceId = 592 and time is not NULL (finished), orders by dob ascending so the earliest date appears first, and returns the forename and surname of the first row (LIMIT 1).",
      "reason": "All required anchors are present: race 592, finished drivers, and identification of the oldest via earliest dob. Using ORDER BY dob ASC LIMIT 1 is an acceptable method for selecting the oldest when tie-handling is unspecified.",
      "verdict": true,
      "evidence": "sql_result shows column names forename, surname with one row (Jean-Pierre Beltoise), matching the expected single oldest driver."
    }
  },
  {
    "question_id": 885,
    "result": {
      "expected_answer": "Name and date of the race that is the last (highest round number) in the 1999 season.",
      "sql_description": "Finds the maximum round within 1999, then returns name and date for the race(s) in 1999 whose round equals that maximum.",
      "reason": "Meets the year=1999 anchor, uses MAX(round) to locate the last round as required, and outputs exactly name and date. Logic aligns with the question.",
      "verdict": true,
      "evidence": "sql_result shows one row: name = 'Japanese Grand Prix', date = '1999-10-31'."
    }
  },
  {
    "question_id": 861,
    "result": {
      "expected_answer": "The driver number for the (single) driver whose Q3 lap time is exactly 0:01:54 in qualifying race 903.",
      "sql_description": "Fetches number from qualifying rows where raceId = 903 and q3 starts with the string '1:54'.",
      "reason": "LIKE '1:54%' may match any 1:54.xx time, not necessarily exactly 0:01:54. It returns two different numbers (1 and 3), so it produces a superset and does not isolate the single driver requested.",
      "verdict": false
    }
  },
  {
    "question_id": 845,
    "result": {
      "expected_answer": "Power names (power_name) possessed by superheroes whose height_cm is more than 80% of the average height of all superheroes.",
      "sql_description": "Joins superheroes with their powers, filters for superheroes with height_cm > 0.8 * (overall average height_cm), and outputs the corresponding superpower.power_name.",
      "reason": "Query applies the correct 80%-of-average height filter and returns the requested power_name field; no other anchors are missing. Duplicate power names are acceptable given the question wording.",
      "verdict": true,
      "evidence": "sql_result shows one column power_name with values such as Agility, Durability, Super Strength, etc. (rows 0-19)."
    }
  },
  {
    "question_id": 978,
    "result": {
      "expected_answer": "For each circuit located in Austria, provide the number of times races were held there together with the circuit’s location name and its latitude and longitude.",
      "sql_description": "Joins circuits with races, keeps only circuits where country = 'Austria', groups by each circuit’s location and coordinates, and returns the count of race rows (times held) alongside that location, lat and lng.",
      "reason": "All required anchors are covered: restricted to Austria, counts occurrences of races (\"times held\"), and outputs location plus lat/lng. Output granularity (per circuit) is reasonable given the request for location and coordinates.",
      "verdict": true,
      "evidence": "Result columns: COUNT(T1.location) (times) | location | lat | lng, rows e.g. (29, 'Spielburg', 47.2197, 14.7647) and (1, 'Styria', 47.2039, 14.7478)"
    }
  },
  {
    "question_id": 898,
    "result": {
      "expected_answer": "Return the name (forename + surname) and current age of the youngest driver whose nationality is Japanese, using age = current year − birth year.",
      "sql_description": "Gets all drivers with nationality='Japanese', computes their age via year difference, orders by dob descending (newest birth date = youngest) and returns the first row (name and age).",
      "reason": "Captures required anchors (nationality filter, youngest via dob, provides name and age). Calculation method aligns with evidence; result limited to the single youngest driver.",
      "verdict": true,
      "evidence": "Row0: forename='Kamui', surname='Kobayashi', age=39"
    }
  },
  {
    "question_id": 766,
    "result": {
      "expected_answer": "The full name(s) of the superhero(es) whose strength attribute value is the maximum among all heroes.",
      "sql_description": "Joins superhero with hero_attribute and attribute, restricts to attribute_name = 'Strength', then filters rows whose attribute_value equals the global MAX strength value found in a subquery; returns the associated full_name field.",
      "reason": "Query applies correct anchor (Strength), computes maximum value, and returns the full names of all heroes reaching that max. Matches the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows column full_name with 20 rows, indicating heroes tied at the maximum strength value."
    }
  },
  {
    "question_id": 801,
    "result": {
      "expected_answer": "A numeric value giving the ratio of male superheroes to female superheroes (count of males divided by count of females).",
      "sql_description": "Counts superheroes with gender_id = 1, counts those with gender_id = 2, and returns the first count divided by the second as the ratio.",
      "reason": "The query implements a clear interpretation of the requested ratio (male/female). The question’s wording does not fix the numerator order, and the evidence explicitly frames the ratio as SUM(gender_id=1)/SUM(gender_id=2). All required anchors (male, female counts) are present, so the SQL satisfies the request.",
      "verdict": true,
      "evidence": "sql_result row0 ratio=2.55665"
    }
  },
  {
    "question_id": 909,
    "result": {
      "expected_answer": "A numeric percentage showing what portion of all races named \"European Grand Prix\" took place in Germany.",
      "sql_description": "Filters races to those with name = 'European Grand Prix', joins to circuits for country, counts total such races and counts those whose country is Germany, then returns (German / total)*100 as percentage.",
      "reason": "Query applies the required race-name filter, correctly determines host country via circuits, and computes the requested percentage. All explicit anchors are satisfied.",
      "verdict": true,
      "evidence": "percentage column: row0=52.173913"
    }
  },
  {
    "question_id": 949,
    "result": {
      "expected_answer": "The name of the constructor that has accumulated the greatest number of points among all constructor standings records.",
      "sql_description": "Joins constructors with constructorStandings, aggregates points per constructor with SUM(points), orders by this total descending, and returns the single constructor name with the largest sum.",
      "reason": "A reasonable reading of \"highest point\" is the constructor with the greatest cumulative points. The query correctly computes total points per constructor and picks the top one; no anchors are missed.",
      "verdict": true,
      "evidence": "sql_result row 0 column name = 'Ferrari'"
    }
  },
  {
    "question_id": 984,
    "result": {
      "expected_answer": "The introduction website (URL) of the constructor whose accumulated wins across all constructorStandings records are the highest.",
      "sql_description": "Joins constructors with constructorStandings, aggregates total wins per constructor, orders constructors by this sum in descending order, and returns the URL of the top constructor (highest total wins).",
      "reason": "Query applies correct aggregation on wins, identifies the constructor with the maximum total, and outputs its website URL, satisfying all stated constraints (constructor identity, total wins criterion, website field).",
      "verdict": true,
      "evidence": "sql_result includes one column 'url' with value http://en.wikipedia.org/wiki/Scuderia_Ferrari (row 0)."
    }
  },
  {
    "question_id": 1032,
    "result": {
      "expected_answer": "League name with the greatest number of matches ever recorded, together with that match count.",
      "sql_description": "Counts matches per league in Match, joins to League to fetch the league name, orders by the count descending and returns the top record (name and count).",
      "reason": "All required anchors satisfied: uses Match for match records, groups by league, obtains highest COUNT, returns league name and total matches. Output therefore answers the question.",
      "verdict": true,
      "evidence": "Row0: name='Spain LIGA BBVA', COUNT=3040"
    }
  },
  {
    "question_id": 868,
    "result": {
      "expected_answer": "Latitude and longitude of the circuit that hosts the Malaysian Grand Prix.",
      "sql_description": "Joins races with circuits, filters races where name = 'Malaysian Grand Prix', returns the circuit's lat and lng for those races.",
      "reason": "Query targets the correct race name and outputs the requested coordinates. Extra duplicate rows do not alter the values, so the result set still answers the question accurately.",
      "verdict": true,
      "evidence": "sql_result rows show lat=2.76083, lng=101.738 for all returned records."
    }
  },
  {
    "question_id": 989,
    "result": {
      "expected_answer": "Return the driver who finished in 1st place at the 2008 Canadian Grand Prix and show his recorded finishing time.",
      "sql_description": "Looks up the race named \"Canadian Grand Prix\" in 2008, joins to results, filters to the row where position = 1, then returns the driver’s forename, surname, and the time value.",
      "reason": "All explicit anchors (race name, year 2008, champion position) are applied and the selected columns give the requested driver identity and finish time, so the query fully answers the question.",
      "verdict": true,
      "evidence": "Row0: forename=Robert, surname=Kubica, time=1:36:24.227"
    }
  },
  {
    "question_id": 878,
    "result": {
      "expected_answer": "Full name (forename and surname) of the driver whose lap time is the minimum among all lapTimes rows for raceId 348 (the fastest single lap in that race).",
      "sql_description": "Joins drivers with lapTimes, filters to raceId 348, orders every lap record by the textual time column ascending and takes the first row, returning that driver’s forename and surname.",
      "reason": "Query applies correct race filter and picks the driver with the smallest recorded lap time row, fulfilling the ‘best lap’ requirement. Although it orders on the string-formatted time rather than the numeric milliseconds, this still yields the same driver when all laps share the same minutes format—an interpretation consistent with common F1 data and not contradicted by schema or evidence. All explicit anchors (race 348, best lap, driver full name) are met.",
      "verdict": true,
      "evidence": "sql_result shows row 0 columns (forename, surname) = (Sebastian, Vettel)."
    }
  },
  {
    "question_id": 874,
    "result": {
      "expected_answer": "The driver who placed 2nd (position = 2) in the 2006 San Marino Grand Prix.",
      "sql_description": "Looks up the 2006 race named 'San Marino Grand Prix', selects the result where position = 2, joins to drivers, and returns the driver's surname.",
      "reason": "All explicit anchors (race name, year 2006, finishing position 2) are enforced. Returning the surname is a reasonable identification of the driver, so the query answers the question.",
      "verdict": true,
      "evidence": "surname -> Alonso (row 0)"
    }
  },
  {
    "question_id": 1020,
    "result": {
      "expected_answer": "The player_api_id of the player whose overall_rating is the maximum value in Player_Attributes (ties can return any one).",
      "sql_description": "Looks at all rows with non-NULL overall_rating in Player_Attributes, orders them by overall_rating descending, and returns the player_api_id of the first (highest-rated) row.",
      "reason": "Captures the required anchor (MAX overall_rating) by ordering DESC LIMIT 1 and returns the requested field (player_api_id). Duplicate rows or ties are acceptable under the question wording.",
      "verdict": true,
      "evidence": "sql_result shows column player_api_id with value 30981 in first row."
    }
  },
  {
    "question_id": 1158,
    "result": {
      "expected_answer": "All patients (identifiers) who were born in 1937 and have any laboratory record where total cholesterol (T-CHO) is 250 or higher, i.e., above the normal range.",
      "sql_description": "Joins Patient with Laboratory on ID, keeps rows where the birth year extracted from Patient.Birthday equals 1937 and Laboratory.T-CHO is at least 250, then returns distinct Patient.ID values.",
      "reason": "Both explicit anchors are satisfied: birth year 1937 and T-CHO ≥ 250. The query outputs distinct patient IDs, an acceptable representation of the requested patient list.",
      "verdict": true,
      "evidence": "sql_result shows one matching ID column (e.g., row0.ID=1078741), confirming the query returns patient identifiers."
    }
  },
  {
    "question_id": 927,
    "result": {
      "expected_answer": "Return the forename and surname of the driver who achieved the highest recorded fastestLapSpeed in any Formula 1 race result.",
      "sql_description": "Looks up each result’s fastestLapSpeed, joins to the drivers table, orders all records by fastestLapSpeed descending, and picks the top row, outputting that driver’s forename and surname.",
      "reason": "The query applies the correct anchor (global maximum of fastestLapSpeed) and retrieves exactly the requested fields. Tie-handling is unspecified in the question, so LIMIT 1 is acceptable.",
      "verdict": true,
      "evidence": "Row0: forename=Vitantonio, surname=Liuzzi"
    }
  },
  {
    "question_id": 1068,
    "result": {
      "expected_answer": "A single number: the mean overall_rating of all Player_Attributes records dated 2010-2015 (inclusive) that belong to players whose height is greater than 170 cm.",
      "sql_description": "Joins Player with Player_Attributes, keeps rows where Player.height > 170 and the attribute record year is between 2010 and 2015, then returns AVG(overall_rating) over those rows.",
      "reason": "Query applies the required height, date, and table joins and computes the correct aggregate; matches the stated formula (average over attribute records).",
      "verdict": true,
      "evidence": "sql_result shows column AVG(T2.overall_rating) with value 68.945204 for the single row returned."
    }
  },
  {
    "question_id": 1090,
    "result": {
      "expected_answer": "Return the long_passing score (0-100) for the player whose birthday is earliest in the Player table (i.e., the oldest player).",
      "sql_description": "Find the minimum birthday in Player, select the Player(s) with that birthday, join to Player_Attributes on player_api_id, and output one long_passing value for that player (LIMIT 1).",
      "reason": "Query respects the required anchor (oldest birthday) and retrieves the requested attribute long_passing. The question does not specify which season/date’s attribute to use, so returning any available record is a reasonable interpretation. LIMIT 1 is acceptable even if multiple identical-birthday players or attribute rows exist.",
      "verdict": true,
      "evidence": "Result shows long_passing column with value 75 (row 0)."
    }
  },
  {
    "question_id": 942,
    "result": {
      "expected_answer": "A single number: the average of Lewis Hamilton's fastest lap times across every race, expressed in total seconds (minutes*60 + seconds + milliseconds/1000).",
      "sql_description": "Joins drivers to results for rows where the driver is Lewis Hamilton, then computes AVG( SUBSTR(fastestLapTime,4,2)*60 + SUBSTR(fastestLapTime,7) ) — i.e. treats characters 4-5 as minutes, characters 7-end as seconds, and returns their average.",
      "reason": "Conversion logic is wrong: SUBSTR(4,2) actually extracts the seconds field, not minutes, so it multiplies seconds by 60; the milliseconds part is taken as an integer number of seconds, with no division by 1000. Minutes are ignored and milliseconds are mis-scaled, producing an incorrect average. Therefore the SQL does not answer the question correctly.",
      "verdict": false
    }
  },
  {
    "question_id": 948,
    "result": {
      "expected_answer": "A single numeric value: the highest points value recorded in constructorStandings for any constructor whose nationality is British.",
      "sql_description": "Calculates the average (AVG) of the points for all standings rows where the constructor’s nationality is British.",
      "reason": "Question asks for the maximum, not the average. Required anchor MAX points is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1131,
    "result": {
      "expected_answer": "A single numeric value: the mean height of all Italian players (i.e., players associated with Italy).",
      "sql_description": "Calculates AVG(height) for players whose player_api_id happens to equal Match.home_player_1 in matches whose country_id refers to a league whose country name is 'Italy'. Players in any other match-lineup positions or appearing only as away players are ignored; duplicates per match inflate the average.",
      "reason": "Key anchor ‘all Italy players’ is not met: the query only looks at home_player_1, omitting the vast majority of Italian-league players and double-counts them per appearance. Therefore the result is not a correct average for Italy players.",
      "verdict": false
    }
  },
  {
    "question_id": 1159,
    "result": {
      "expected_answer": "IDs, sex, and diagnosis of all patients whose laboratory albumin (ALB) value is lower than 3.5.",
      "sql_description": "Joins Patient with Laboratory on patient ID and selects ID, SEX, Diagnosis for every lab record where ALB < 3.5 (thus possibly duplicating a patient if several low-albumin tests exist).",
      "reason": "Satisfies the only explicit anchor (ALB < 3.5) and returns exactly the requested fields. Question does not forbid duplicates, so the result format is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows columns ID, SEX, Diagnosis (e.g., rows 0-9 ID=27654 F RA, SLE susp; row 10 ID=57266 M RA), confirming the expected structure."
    }
  },
  {
    "question_id": 1015,
    "result": {
      "expected_answer": "The particular Formula 1 race (e.g., 2020 Austrian Grand Prix, 2021 Styrian Grand Prix, etc.) during which the single fastest lap ever recorded at the Austrian Grand Prix Circuit was set.",
      "sql_description": "Finds all lap-times from races whose name is exactly 'Austrian Grand Prix', orders them by lap time, then returns the circuit’s name (Red Bull Ring) for the fastest lap.",
      "reason": "The query outputs the circuit name instead of the race, so it does not answer which race set the lap record. It also ignores other races run on the same circuit that might hold the record.",
      "verdict": false
    }
  },
  {
    "question_id": 1244,
    "result": {
      "expected_answer": "All patients whose First Date year is later than 1992 and whose prothrombin time (PT) value is in the normal range (PT < 14). Return their patient identifiers (any form listing all such patients is acceptable).",
      "sql_description": "Joins Patient and Laboratory on patient ID, keeps rows where the year extracted from Patient.First Date is greater than 1992 and Laboratory.PT is less than 14, then returns the distinct patient IDs.",
      "reason": "The query enforces both required anchors: First Date year > 1992 and PT < 14. DISTINCT removes duplicates per patient, fulfilling the request to list all qualifying patients. No contradictory or missing constraints detected.",
      "verdict": true,
      "evidence": "Result shows one column ID with 20 distinct patient IDs (e.g., 944797, 1110526, ... 4934716)."
    }
  },
  {
    "question_id": 1241,
    "result": {
      "expected_answer": "Return the difference between the number of distinct patients whose platelet count is lower than 100 (low-range) and the number of distinct patients whose platelet count is higher than 400 (high-range):  (low-range patient count) minus (high-range patient count).",
      "sql_description": "Counts rows, not distinct patients, where PLT < 100 and PLT > 400, then subtracts the two sums to give a difference based on row counts.",
      "reason": "Question asks for patient counts (distinct IDs). The query counts lab records; a patient with multiple measurements is over-counted. Required anchor ‘distinct patients’ is missing, so result is not guaranteed to match the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1013,
    "result": {
      "expected_answer": "The single fastest lap time ever recorded at the Austrian Grand Prix circuit, expressed as the lap-time value.",
      "sql_description": "Finds every lap in races whose name is exactly 'Austrian Grand Prix' and returns the minimum value of the string-encoded lap time, i.e. the quickest of those laps.",
      "reason": "Interpreting the question as asking for the lap record of the Austrian Grand Prix (same circuit), the query correctly aggregates all laps from that event and returns the fastest time. Filtering on race name reasonably identifies the circuit, and taking MIN(time) yields the lap record; the result type matches what is requested.",
      "verdict": true,
      "evidence": "sql_result shows one row with column MIN(lt.time) = '1:07.411', which is the fastest lap time found."
    }
  },
  {
    "question_id": 1130,
    "result": {
      "expected_answer": "All team_short_name values for teams whose chanceCreationPassingClass is 'Safe' (teams that \"played safe\" in chance-creation passing).",
      "sql_description": "Joins Team with Team_Attributes and returns team_short_name for every Team_Attributes row where chanceCreationPassingClass = 'Safe'.",
      "reason": "Query applies the required filter on chanceCreationPassingClass='Safe' and outputs the requested team_short_name; no other anchors are missing. Duplicate names are acceptable as uniqueness was not demanded.",
      "verdict": true,
      "evidence": "sql_result shows team_short_name column with values such as 'HAA', 'ARK', 'ARS', 'BAR', etc., matching the expected content."
    }
  },
  {
    "question_id": 1359,
    "result": {
      "expected_answer": "A numeric factor showing how many times the Advertisement budget sum for the \"Yearly Kickoff\" event exceeds that for the \"October Meeting\" event (Yearly Kickoff total ÷ October Meeting total).",
      "sql_description": "Joins budget to event, keeps only Advertisement rows, sums amount for rows whose event_name is \"Yearly Kickoff\" and for those whose event_name is \"October Meeting\", then divides the first sum by the second, returning that ratio as budget_ratio.",
      "reason": "Query filters to category='Advertisement', correctly isolates the two specified events via CASE conditions, aggregates their amounts and returns the quotient, matching the requested \"how many times\" comparison.",
      "verdict": true,
      "evidence": "sql_result shows column budget_ratio with value 2, providing the required numeric factor."
    }
  },
  {
    "question_id": 1165,
    "result": {
      "expected_answer": "The number of years between the birth year of the youngest patient and the birth year of the oldest patient among patients whose triglyceride (TG) test result is at least 200.",
      "sql_description": "Finds all laboratory records with TG < 200, joins to the related patients, takes the latest and earliest birth years among those patients and returns their difference.",
      "reason": "The question defines \"normal triglyceride\" as TG >= 200, but the SQL filters TG < 200, selecting the wrong cohort. Therefore the computed age gap does not correspond to the requested group.",
      "verdict": false
    }
  },
  {
    "question_id": 1391,
    "result": {
      "expected_answer": "A single numeric value representing the count of students whose major is Finance divided by the count of students whose major is Physics (finance-to-physics ratio).",
      "sql_description": "Counts member rows joined to their major; sums 1 for each Finance major and for each Physics major, then divides finance count by physics count to give the ratio.",
      "reason": "Question asks for student ratio by major. Query counts members per major via join and computes finance_count / physics_count, matching required anchors (students, Finance, Physics) and returns single numeric ratio.",
      "verdict": true,
      "evidence": "Result set has one column (finance/physics ratio); current data returned NULL, confirming query runs and structure correct."
    }
  },
  {
    "question_id": 1257,
    "result": {
      "expected_answer": "Number of distinct patients whose creatinine value is 1.5 or higher (abnormal) and whose age is less than 70 years.",
      "sql_description": "Joins Patient with Laboratory on ID, filters lab rows with CRE ≥ 1.5 and patients younger than 70, then counts all resulting Patient IDs (no DISTINCT).",
      "reason": "Question asks for a patient count, requiring each patient to be counted once. Query counts one row per abnormal-lab record, so patients with multiple abnormal tests are over-counted; anchor of distinct patients is unmet.",
      "verdict": false
    }
  },
  {
    "question_id": 999,
    "result": {
      "expected_answer": "Race name whose recorded fastestLapTime is the minimum among all racers/results (i.e., the race with the overall quickest lap).",
      "sql_description": "Joins results with races, sorts all records by fastestLapTime ascending and returns the name of the race from the first (smallest-time) row, limited to one.",
      "reason": "Query applies MIN fast-lap criterion via ORDER BY fastestLapTime ASC LIMIT 1, outputs the associated race name, satisfying the request for the race that registered the quickest lap. Potential string ordering issues are negligible because lap times share uniform format; anchors (fastest lap time, race name) are met.",
      "verdict": true,
      "evidence": "sql_result shows column name → Australian Grand Prix (row 0)."
    }
  },
  {
    "question_id": 1261,
    "result": {
      "expected_answer": "Return the count of distinct patients (unique IDs) whose RF value is below 20 (normal) and whose Thrombosis flag equals 0 (no thrombosis).",
      "sql_description": "Counts all joined rows from Laboratory and Examination where Laboratory.RF < 20 and Examination.Thrombosis = 0, without deduplicating patient IDs.",
      "reason": "The question asks for the number of patients, implying unique individuals. The query counts rows, not DISTINCT IDs, so patients with multiple examinations or lab records could be over-counted. Required anchor of distinct patient counting is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1404,
    "result": {
      "expected_answer": "For the event named 'October Meeting', return the expense type (likely the budget.category or expense.expense_description) together with the sum of cost of the expenses that are approved.",
      "sql_description": "Gets the event name and the total SUM(cost) of expenses that are approved for that event; does not return any expense type/category.",
      "reason": "Question asks for both the type of expenses and their total value; query only provides total value (and event name), omitting the expense type anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1227,
    "result": {
      "expected_answer": "A single numeric value: the average age (in years) of male patients whose total cholesterol (T-CHO) is at least 250, counting each qualifying patient once.",
      "sql_description": "Joins Patient and Laboratory, filters rows with patient.sex = 'M' and T-CHO >= 250, then takes AVG of (current year - birth year) across all resulting joined rows.",
      "reason": "Because Laboratory can store multiple test dates per patient, the query averages over lab records, not distinct patients, so patients with several high-cholesterol tests are over-counted. The question asks for an average per patient, so DISTINCT (or grouping by patient) is required. Other anchors are met, but this duplication violates the core requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 1422,
    "result": {
      "expected_answer": "List of event categories (i.e., the values in the \"type\" field) for all events whose location is MU 215.",
      "sql_description": "Retrieves the \"type\" column for every record in event where location equals 'MU 215'.",
      "reason": "Query applies the required location anchor and returns the category field asked for. Duplicates do not violate any explicit requirement, so the result set suffices.",
      "verdict": true,
      "evidence": "sql_result shows column type with values such as Meeting, Election, Guest Speaker – all tied to MU 215."
    }
  },
  {
    "question_id": 1104,
    "result": {
      "expected_answer": "The potential rating value for the player Francesco Parravicini on 2010-08-30.",
      "sql_description": "Looks up Player_Attributes joined with Player, filters player_name = 'Francesco Parravicini' and date = '2010-08-30 00:00:00', then returns the potential column.",
      "reason": "Query honors both required anchors (specific player and exact date) and selects the requested attribute (potential). Therefore it directly answers the question.",
      "verdict": true,
      "evidence": "sql_result shows potential column with value 70 for the matched row."
    }
  },
  {
    "question_id": 1480,
    "result": {
      "expected_answer": "Identify which month in 2013 (e.g., 201301-201312 or month number) had the highest total gas consumption when summing consumption for all SME segment customers.",
      "sql_description": "Joins SME customers with their monthly records, then orders all individual customer-month rows of 2013 by Consumption DESC and returns the Date of the single row with the largest individual consumption.",
      "reason": "Query looks at the maximum consumption of a single customer record, not the aggregate consumption per month across all SME customers, so it can select a month that is not the true peak of total SME consumption.",
      "verdict": false
    }
  },
  {
    "question_id": 1129,
    "result": {
      "expected_answer": "All team_long_name values of teams whose buildUpPlaySpeedClass is 'Slow'.",
      "sql_description": "Joins Team to Team_Attributes, filters rows where buildUpPlaySpeedClass = 'Slow', then returns the associated team_long_name values.",
      "reason": "Query applies the required 'Slow' speed class filter and outputs the requested long team names; duplicates are tolerable because the question does not forbid them.",
      "verdict": true,
      "evidence": "sql_result shows column team_long_name with examples such as 'Académica de Coimbra', 'Ajax', 'FC Barcelona' (rows 0-10)."
    }
  },
  {
    "question_id": 1473,
    "result": {
      "expected_answer": "A single numeric value: the average monthly consumption of customers whose segment is SME over the 2013 calendar year.",
      "sql_description": "Joins yearmonth with customers, keeps rows where Segment = 'SME' and Date starts with '2013', averages their Consumption values and divides the result by 12, labelling it average_monthly_consumption.",
      "reason": "Fulfils all anchors: filters SME customers, restricts dates to 2013 via '2013%', applies the indicated formula AVG(Consumption)/12 per evidence, and returns the required single average value.",
      "verdict": true,
      "evidence": "sql_result contains one column average_monthly_consumption with value 459.956264 (row 0)."
    }
  },
  {
    "question_id": 1294,
    "result": {
      "expected_answer": "Patient ID(s) whose creatinine is below 1.5 (normal) and whose aCL IgA value is the maximum among those normal-creatinine patients.",
      "sql_description": "Joins Laboratory and Examination on ID, keeps rows where Laboratory.CRE < 1.5, sorts by Examination.`aCL IgA` descending, and returns the first ID, i.e., the patient with the highest aCL IgA among patients with normal creatinine.",
      "reason": "Both required anchors are met: creatinine < 1.5 filter and ordering by aCL IgA to pick the maximum (LIMIT 1). Minor duplication from multiple lab/exam rows does not change the highest value selection, so the returned ID correctly answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column ID = 1567380, matching the requested output structure."
    }
  },
  {
    "question_id": 1472,
    "result": {
      "expected_answer": "The customer (CustomerID) within the LAM segment whose total consumption in all 2012 months (201201-201212) is the smallest among LAM customers.",
      "sql_description": "Filters rows for LAM customers and dates 201201-201212, then simply picks the single row with the minimum monthly Consumption value and returns that row’s CustomerID (no aggregation across the year).",
      "reason": "Question implies comparing customers’ 2012 consumption as a whole; this requires summing (or otherwise aggregating) each customer’s 2012 consumption before finding the minimum. The SQL instead looks at individual monthly records, so a customer with one unusually low month but high total could be wrongly chosen. Missing aggregation anchor → incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1529,
    "result": {
      "expected_answer": "Two monetary totals for customer 38508: (1) overall money spent at gas stations; (2) money spent in January 2012 (Date starting with 201201). Totals should reflect money, i.e., quantity * price.",
      "sql_description": "Returns two rows: (a) SUM(Amount) over all transactions of customer 38508, (b) SUM(Amount) for that customer where Date LIKE '201201%'. It adds no price component.",
      "reason": "The query sums the Amount column, which is quantity, not expenditure. Spending should aggregate Amount*Price (or an equivalent monetary field). Therefore it does not answer the question about money spent.",
      "verdict": false
    }
  },
  {
    "question_id": 1177,
    "result": {
      "expected_answer": "A yes/no (true/false) indication of whether patient 2927464’s total cholesterol (T-CHO) on 1995-09-04 was below the normal-level threshold of 250.",
      "sql_description": "Retrieves the T-CHO value for patient 2927464 on 1995-09-04 and returns a Boolean column is_normal that is 1 if T-CHO < 250 and 0 otherwise.",
      "reason": "Query applies all required anchors (patient id, date, total cholesterol) and evaluates the specified normal-level criterion (<250), producing a direct Boolean answer matching the question’s yes/no request.",
      "verdict": true,
      "evidence": "sql_result shows column is_normal with value 1 (row 0), meaning the level was normal."
    }
  },
  {
    "question_id": 1510,
    "result": {
      "expected_answer": "Average of (Amount * Price) across all transactions occurring at gas stations whose Country = 'CZE'.",
      "sql_description": "Joins transactions_1k with gasstations, filters rows where gasstations.Country = 'CZE', computes AVG(Amount * Price) over those transactions.",
      "reason": "All required anchors (Czech Republic gas stations and total price per transaction) are present and correctly used; calculation matches question intent.",
      "verdict": true,
      "evidence": "avg_total_price column returned with one value (row 0: 18696.139271)."
    }
  },
  {
    "question_id": 1481,
    "result": {
      "expected_answer": "Three numbers: (1) SME annual-average consumption of the lowest-consuming CZK customers in 2013 minus that of LAM, (2) LAM minus KAM, and (3) KAM minus SME. Annual-average consumption is defined as total 2013 consumption of all customers who share the minimum annual consumption in the segment divided by the number of those customers.",
      "sql_description": "For each segment (SME, LAM, KAM) the query selects the single yearmonth row with the smallest monthly Consumption in 2013 (Currency CZK) and takes its average (trivially the same value). It then computes pairwise differences between those three single-row values.",
      "reason": "The query uses per-row monthly consumption, not the customers’ annual totals, does no aggregation per customer or year, and ignores other customers who share the minimum. Therefore the computed differences do not correspond to the requested annual average consumption of the lowest-consuming customers.",
      "verdict": false
    }
  },
  {
    "question_id": 1214,
    "result": {
      "expected_answer": "A list of each patient (ID, SEX, Birthday) who ever had a laboratory TP value below 6.0, i.e., below the normal lower limit.",
      "sql_description": "Joins Patient with Laboratory on ID and returns ID, SEX and Birthday for every lab record whose TP < 6.0 (duplicates possible for patients with multiple such records).",
      "reason": "It applies the required TP < 6.0 filter and returns the requested fields. Although it may output the same patient multiple times because it lacks DISTINCT, duplicates do not add incorrect information and the question does not explicitly demand uniqueness, so the core requirement is satisfied.",
      "verdict": true,
      "evidence": "sql_result shows rows with columns [ID, SEX, Birthday], all TP-low patients (e.g., ID 27654, 57266, 287122, 287861)."
    }
  },
  {
    "question_id": 137,
    "result": {
      "expected_answer": "The number of distinct accounts (unique account_id values) whose branch/district_id is 1 and that have at least one loan whose status is 'C' or 'D' (running contracts).",
      "sql_description": "Joins account with loan, filters to account.district_id = 1 and loan.status in ('C','D'), then counts every resulting account row without DISTINCT.",
      "reason": "Question asks for how many accounts—implying unique accounts—have running contracts. Query counts loan-level rows; an account with multiple running loans would be counted multiple times. Lacks DISTINCT on account_id, so required uniqueness anchor is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1271,
    "result": {
      "expected_answer": "The count of distinct patients whose anti-SSA lab result is normal (value '-' or '+-') and whose first hospital visit date is before the year 2000.",
      "sql_description": "Counts distinct patient IDs where their anti-SSA value equals '0' or '+' and the year extracted from their First Date is less than 2000.",
      "reason": "Incorrect SSA filter: uses ('0', '+') instead of required normal set ('-', '+-'), violating the explicit anchor for normal anti-SSA. Therefore the query does not target the specified patient group.",
      "verdict": false
    }
  },
  {
    "question_id": 1514,
    "result": {
      "expected_answer": "Return the currency type(s) of the customer(s) who made a payment at 16:25:00 on 2012-08-24.",
      "sql_description": "Joins customers with transactions_1k, filters transactions to Date = '2012-08-24' and Time = '16:25:00', then selects the corresponding Currency values.",
      "reason": "Query applies the required date and time anchors and retrieves the customers’ currency; duplicates do not violate the question. Result shows the currency at that moment.",
      "verdict": true,
      "evidence": "sql_result rows: Currency column = ['CZK', 'CZK', 'CZK'] (rows 0-2) indicating the payment(s) were in CZK."
    }
  },
  {
    "question_id": 86,
    "result": {
      "expected_answer": "Return the last name of the primary administrator (AdmLName1) together with the District, County and School name for the school whose CharterNum is 40.",
      "sql_description": "Selects AdmLName1, District, County, School from schools where CharterNum equals '40'.",
      "reason": "All required anchors—CharterNum=40 and the requested four columns—are present; the query directly answers the question with no extraneous filters.",
      "verdict": true,
      "evidence": "sql_result has columns [AdmLName1, District, County, School] and 0 rows, showing structure matches though dataset lacks matching record."
    }
  },
  {
    "question_id": 1430,
    "result": {
      "expected_answer": "Return the last_name and position of the member who made an expense with expense_description = 'Pizza' on the date 2019-09-10.",
      "sql_description": "Joins member with expense via member_id, filters expenses to description 'Pizza' and date '2019-09-10', outputs the member's last_name and position.",
      "reason": "All required anchors (description Pizza, date 2019-09-10) are applied; outputs exactly the requested attributes.",
      "verdict": true,
      "evidence": "sql_result shows one row: last_name=Cullen, position=Vice President."
    }
  },
  {
    "question_id": 2,
    "result": {
      "expected_answer": "Zip codes of every charter school whose administrative authority is the Fresno County Office of Education (i.e., schools belonging to that district).",
      "sql_description": "Returns schools.Zip after joining schools with frpm where frpm.`Charter School (Y/N)` = 1 and schools.County equals the literal string 'Fresno County Office of Education'.",
      "reason": "The query anchors on schools.County, but the identifying phrase 'Fresno County Office of Education' refers to the district/COE, not the County field (which normally holds just 'Fresno'). Consequently it omits the intended schools (empty result shown). Required location anchor is therefore mis-applied.",
      "verdict": false
    }
  },
  {
    "question_id": 1465,
    "result": {
      "expected_answer": "Return the budget category associated with the expense whose description is 'Posters'.",
      "sql_description": "Joins expense with budget on link_to_budget, filters rows where expense_description = 'Posters', and outputs the corresponding budget.category values.",
      "reason": "Query includes the required anchor (expense_description = 'Posters') and retrieves the linked budget category; duplicates do not affect correctness.",
      "verdict": true,
      "evidence": "sql_result shows category column rows 0-5 all equal to 'Advertisement', indicating the category for 'Posters'."
    }
  },
  {
    "question_id": 273,
    "result": {
      "expected_answer": "Percentage = (number of atoms whose element = 'cl' in carcinogenic (label '+') molecules) ÷ (total number of atoms in those carcinogenic molecules) × 100.",
      "sql_description": "Counts chlorine atoms in carcinogenic molecules and divides by the count of DISTINCT carcinogenic molecules containing chlorine, then multiplies by 100.",
      "reason": "Denominator should be all atoms (or at least all carcinogenic molecules), but query limits it to molecules that already contain chlorine, changing the measure to ‘average chlorine atoms per chlorine-bearing molecule’. Required anchor of using the full carcinogenic set is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 172,
    "result": {
      "expected_answer": "A single number representing the total count of disposition records whose account_id is between 1 and 10 (inclusive) and whose type is either 'OWNER' or 'DISPONENT'.",
      "sql_description": "Counts all rows in disp where account_id is 1–10 and type is 'OWNER' or 'DISPONENT'.",
      "reason": "Query applies the required account range filter and type filter, then returns the total count; this satisfies the question, which reasonably asks for a combined total of owner and disponent dispositions.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(disp_id)=13 (column COUNT(disp_id), row 0)."
    }
  },
  {
    "question_id": 1284,
    "result": {
      "expected_answer": "The earliest (minimum) Date value for the patient whose maximum lactate dehydrogenase (LDH) value that is still below 500 is the highest among all patients.",
      "sql_description": "For each patient it keeps the row(s) where LDH is that patient’s highest value <500, then picks the globally earliest Date among those rows.",
      "reason": "It never chooses the patient with the overall highest LDH; instead it orders by Date, so the returned date may belong to a patient with a much lower LDH. Anchor ‘highest LDH across all patients’ is missing, therefore the query does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1486,
    "result": {
      "expected_answer": "Need to compare the number of SME customers (or at least SME payment records) whose currency is CZK versus EUR and, if CZK is higher, output the numeric difference in SME counts.",
      "sql_description": "Computes the difference between the total transaction Amount of SME customers in CZK and the total transaction Amount of SME customers in EUR.",
      "reason": "Query uses SUM(Amount) rather than counting SMEs or payment rows, so it answers which currency has higher monetary volume, not whether more SMEs pay in CZK than in EUR. Required count anchor is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 426,
    "result": {
      "expected_answer": "The codes and names of the first three sets (alphabetically by set name) that do not appear in Magic: The Gathering Online (mtgoCode is NULL or empty).",
      "sql_description": "Gets rows from sets where mtgoCode is NULL or '', orders them by name ascending, and returns the first three (code, name).",
      "reason": "All required anchors are satisfied: the mtgoCode absence filter, alphabetical ordering by name, limit to three results, and returning code plus name. Hence the query answers the request exactly.",
      "verdict": true,
      "evidence": "Returned columns: code, name. Row0:P15A 15th Anniversary Cards; Row1:HTR 2016 Heroes of the Realm; Row2:G17 2017 Gift Pack."
    }
  },
  {
    "question_id": 1492,
    "result": {
      "expected_answer": "A numeric percentage representing how many customers in the KAM segment have their Currency set to 'EUR', relative to all KAM customers.",
      "sql_description": "Filters rows where Segment = 'KAM'; counts those whose Currency = 'EUR' and divides by the total count of filtered rows, multiplying by 100 to yield a percentage.",
      "reason": "All required anchors are present: Segment constrained to 'KAM'; currency condition 'EUR'; computation is (count EUR)/(count all KAM)*100, matching the question.",
      "verdict": true,
      "evidence": "Returned one row with column value 3.480392 (percentage_EUR_among_KAM)."
    }
  },
  {
    "question_id": 1441,
    "result": {
      "expected_answer": "Number of club members whose major is 'education' and whose college is 'College of Education & Human Services'. We interpret “members” as students with the position value “Member”.",
      "sql_description": "Counts rows in member joined with major where major_name = 'education', college = 'College of Education & Human Services', and the member’s position equals 'Member'.",
      "reason": "All required anchors—major name, college, and position interpreted as 'Member'—are present. No extraneous constraints. Under the stated interpretation, the query correctly returns the desired count.",
      "verdict": true,
      "evidence": "sql_result shows a single column COUNT(member_id)=0; correct structure supports the answer even if count is zero."
    }
  },
  {
    "question_id": 99,
    "result": {
      "expected_answer": "All account_id values for accounts opened in 1993 that have at least one loan with duration > 12 months and whose approved loan amount equals the maximum approved amount among this filtered group (include every account that ties for that maximum).",
      "sql_description": "Joins account with loan, keeps records where loan.duration > 12 and the account opening year (via strftime) is 1993, orders the remaining rows by loan.amount descending and returns only the first account_id.",
      "reason": "Uses LIMIT 1, so if several accounts share the highest approved amount only one is returned. Question asks to list the accounts with the highest amount (plural, all ties). Therefore the query can omit required results; anchor on returning every qualifying account is unmet.",
      "verdict": false
    }
  },
  {
    "question_id": 284,
    "result": {
      "expected_answer": "List the bond type or types (e.g., '-', '=', '#') that occur in any molecule which contains at least one atom whose element is carbon (element = 'c').",
      "sql_description": "Returns bond_type values from bonds that belong to molecules which contain an atom whose element is 'te' (tellurium).",
      "reason": "The query filters on element 'te' instead of the required element 'c', so the core anchor (carbon) is missing; retrieved bond types are for tellurium-containing molecules, not carbon-containing ones.",
      "verdict": false
    }
  },
  {
    "question_id": 223,
    "result": {
      "expected_answer": "The two atom IDs that are connected by the bond whose bond_id is TR000_2_5.",
      "sql_description": "Fetches all rows from connected where bond_id = 'TR000_2_5', returning the two columns atom_id and atom_id2 that represent the bonded atoms.",
      "reason": "Correctly applies the required anchor (bond_id = TR000_2_5) and outputs the atom IDs involved. Duplicate reverse-order row does not change the set of atoms, so information need is satisfied.",
      "verdict": true,
      "evidence": "Rows returned: (atom_id, atom_id2) → (TR000_2, TR000_5) and (TR000_5, TR000_2)"
    }
  },
  {
    "question_id": 437,
    "result": {
      "expected_answer": "Name(s) of the card or cards whose border color is black and that are marked as full-art.",
      "sql_description": "Retrieves the column 'name' from cards where borderColor = 'black' and isFullArt = 1 (no other filters; may return duplicates).",
      "reason": "Query applies both required anchors—black border and full-art—exactly as asked; returning the card names satisfies the question. No extra or missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows name column with rows like Plains, Island, Swamp, Mountain, Forest, all coming from the applied filter."
    }
  },
  {
    "question_id": 271,
    "result": {
      "expected_answer": "Return \"yes\" if bond TR001_1_8 connects one carbon atom (element = 'c') and one chlorine atom (element = 'cl'); otherwise \"no\".",
      "sql_description": "Looks at rows in connected where bond_id='TR001_1_8', joins ONLY the atom_id column to atom, counts how many of those atoms are carbon or chlorine, and returns 'yes' if both are present.",
      "reason": "Bond involves two atoms (atom_id and atom_id2). Query ignores atom_id2, so it may miss one of the bonded atoms and can give wrong result. Required anchor \"consider both atoms of the bond\" is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 38,
    "result": {
      "expected_answer": "The website URL(s) of the Los Angeles County school(s) whose number of SAT test takers is at least 2,000 and at most 3,000.",
      "sql_description": "Joins satscores to schools on CDS code, keeps rows where the county name in satscores is 'Los Angeles' and NumTstTakr is between 2000 and 3000, then returns DISTINCT Website values.",
      "reason": "The question specifies a school, but satscores contains records for schools (rtype='S'), districts (rtype='D'), and counties (rtype='C'). The query omits the rtype anchor, so district-level rows can pass the filter. The returned URLs (all ending in 'district') indicate they are district sites, not individual schools, so the required 'school' anchor is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 711,
    "result": {
      "expected_answer": "An integer: the count of distinct users who are 40 years old and have at least one comment with score 0.",
      "sql_description": "Joins comments with users, filters to comments whose Score = 0 and users whose Age = 40, then counts distinct UserId values.",
      "reason": "All explicit anchors (score 0, user age 40, distinct users count) are satisfied. No product-specific marker exists in schema so interpreting \"products comments\" as all comments is reasonable.",
      "verdict": true,
      "evidence": "Result has one column COUNT(DISTINCT T1.UserId) with value 31."
    }
  },
  {
    "question_id": 615,
    "result": {
      "expected_answer": "Percentage (0–100) = 100 * (number of distinct users whose Age is between 13 and 18 and who have at least one \"Organizer\" badge) ÷ (total number of distinct users who have an \"Organizer\" badge).",
      "sql_description": "Joins badges and users, keeps rows where badge Name = 'Organizer', then divides the count of rows whose user age is 13-18 by the total count of badge rows to give a percentage.",
      "reason": "Counts badge rows, not distinct users. Question asks about users, so duplicate badge records per user would over-count. Required DISTINCT(UserId) anchor is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 82,
    "result": {
      "expected_answer": "Return the GSoffered value (grade span offered) for the single school whose Longitude value is the greatest (i.e., the maximum longitude).",
      "sql_description": "Selects GSoffered from schools after ordering by ABS(Longitude) in descending order, thereby choosing the school whose longitude has the largest absolute magnitude (furthest east or west), then returns the first record.",
      "reason": "The query orders by ABS(Longitude) instead of Longitude, so it may pick the school with the most negative longitude (largest magnitude) rather than the one with the maximum longitude value. This violates the required anchor 'highest longitude'.",
      "verdict": false
    }
  },
  {
    "question_id": 1491,
    "result": {
      "expected_answer": "For each country, how many gas stations belong to the \"value for money\" segment, and from that list identify the country with the larger count.",
      "sql_description": "Filters gasstations rows to Segment = 'Value for money', groups by Country and counts GasStationID, returning one row per country with its total.",
      "reason": "The query supplies the required counts for every country; the relative comparison (CZE 466 vs SVK 131) directly reveals which country has more, fulfilling both parts of the question.",
      "verdict": true,
      "evidence": "Rows: [Country, totalstations] → (CZE, 466), (SVK, 131)"
    }
  },
  {
    "question_id": 794,
    "result": {
      "expected_answer": "Name of the superhero whose Speed attribute has the highest value (fastest hero).",
      "sql_description": "Joins hero_attribute with attribute and superhero, filters rows where attribute_name is 'Speed', orders by attribute_value descending, returns the superhero_name of the top row (highest speed).",
      "reason": "Query correctly identifies the hero with the maximum Speed attribute by ordering descending and limiting to one, matching the requested fastest hero.",
      "verdict": true,
      "evidence": "sql_result shows one row: superhero_name = 'Air-Walker' (row 0)."
    }
  },
  {
    "question_id": 619,
    "result": {
      "expected_answer": "A single integer: the number of users aged 19-65 (inclusive) who have obtained the badge named \"Supporter\".",
      "sql_description": "Counts distinct user IDs in badges joined with users where badge name is 'Supporter' and user age is between 19 and 65, inclusive.",
      "reason": "Query applies the required badge anchor ('Supporter'), the adult age filter (19-65), and counts unique users, matching the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT u.Id) = 3024 (row 0, column COUNT)."
    }
  },
  {
    "question_id": 189,
    "result": {
      "expected_answer": "All account_id values for female clients whose birth_date equals the minimum among females AND whose district’s A11 (average salary) equals the minimum among females – i.e., clients that are simultaneously the oldest and in the lowest-salary district; may be more than one account.",
      "sql_description": "Joins account-disp-client-district, keeps female rows, then simply sorts by birth_date (earliest first) and, for ties, by A11 ascending, finally returns the very first account_id (LIMIT 1).",
      "reason": "The query captures the oldest female but treats lowest salary only as a tiebreaker, so it can return an account that is not from the overall lowest-salary district. It also limits to a single row, omitting other accounts that satisfy both minima. Thus required anchors (global lowest salary, all qualifying accounts) are not met.",
      "verdict": false
    }
  },
  {
    "question_id": 739,
    "result": {
      "expected_answer": "List of superhero_name values for all superheroes that possess the superpower whose power_name is exactly 'Death Touch'.",
      "sql_description": "Joins superhero -> hero_power -> superpower and returns superhero.superhero_name where superpower.power_name = 'Death Touch'.",
      "reason": "Query applies the necessary power filter ('Death Touch') and retrieves the corresponding superhero names; no extra/missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows column superhero_name with 7 rows (e.g., Black Flash, Hela, Spectre) which are heroes linked to the power 'Death Touch'."
    }
  },
  {
    "question_id": 399,
    "result": {
      "expected_answer": "Return, for cards whose availability is 'arena', the values in the subtypes and supertypes fields – i.e., the card-type information referred to as “all types”.",
      "sql_description": "Selects the subtypes and supertypes columns from the cards table where availability equals 'arena', thereby outputting those type values for every arena-legal card.",
      "reason": "Query applies the required arena filter and outputs both subtype and supertype data, satisfying the request under the reasonable interpretation that the list can contain duplicates and be presented in two columns.",
      "verdict": true,
      "evidence": "sql_result shows columns [subtypes, supertypes] for 20 arena-legal cards, e.g., row0 ('Archon', NULL), row3 ('Demon', NULL), row2 ('Human,Wizard', 'Legendary')."
    }
  },
  {
    "question_id": 402,
    "result": {
      "expected_answer": "Return the percentage of all Story Spotlight cards that are textless (isStorySpotlight = 1, isTextless = 1) using the count of ALL Story Spotlight cards as the denominator, and list the ids of the textless Story Spotlight cards.",
      "sql_description": "The query first restricts the table to rows where isStorySpotlight = 1 AND isTextless = 1, then divides the count of those same rows by COUNT(*) taken over that already-filtered subset, producing 100 for each row, and outputs that value together with each id.",
      "reason": "It computes the percentage against only the textless Story Spotlight subset instead of against all Story Spotlight cards, so the percentage is always 100 and incorrect. Therefore the query does not satisfy the question’s requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 872,
    "result": {
      "expected_answer": "The abbreviated driver code (drivers.code) for the driver whose Q3 lap time starts with 0:01:33 in raceId 45.",
      "sql_description": "Joins qualifying, races, drivers and returns drivers.code where raceId = 45 and q3 is exactly '0:01:33'.",
      "reason": "Question asks for the driver whose Q3 time begins with 0:01:33; evidence suggests the field may include additional milliseconds so a LIKE pattern is required. Predicted SQL demands an exact match, producing no rows, so it fails to identify the driver.",
      "verdict": false
    }
  },
  {
    "question_id": 563,
    "result": {
      "expected_answer": "The favorite count (integer) of the post that received the comment made by user 3025 at 2014-04-23 20:29:39.",
      "sql_description": "Selects the post linked to the comment whose UserId = 3025 and CreationDate = '2014-04-23 20:29:39.0', then returns that post's FavoriteCount.",
      "reason": "All explicit anchors (user id, exact comment timestamp, favorite count of the associated post) are present and correctly handled; the query’s output therefore answers the question.",
      "verdict": true,
      "evidence": "FavoriteCount column in result row 0 equals 3"
    }
  },
  {
    "question_id": 213,
    "result": {
      "expected_answer": "Return the bond_type (e.g. '-', '=', '#', etc.) that represents the bond connecting atoms TR004_8 and TR004_20, regardless of which atom appears first in the connected table.",
      "sql_description": "Joins connected to bond and returns bond_type where connected.atom_id = 'TR004_8' and connected.atom_id2 = 'TR004_20'. It does not consider the reverse ordering.",
      "reason": "The question/evidence requires finding the bond between the two atoms in either orientation (atom_id='TR004_8' AND atom_id2='TR004_20' OR the reverse). The query checks only one orientation, missing a mandatory anchor, so it could fail if the row is stored the other way around.",
      "verdict": false
    }
  },
  {
    "question_id": 849,
    "result": {
      "expected_answer": "The URL(s) that contain the introduction pages for every race held at the circuit named \"Circuit de Barcelona-Catalunya\".",
      "sql_description": "Joins races with circuits then selects races.url for rows whose circuit name is exactly 'Circuit de Barcelona-Catalunya'.",
      "reason": "Question asks for where (URL) the introductions of races at that circuit can be found. Query correctly filters by the specified circuit and returns the url column, which stores the introduction link.",
      "verdict": true,
      "evidence": "sql_result shows many urls column values such as row0 'http://en.wikipedia.org/wiki/2009_Spanish_Grand_Prix', confirming correct field returned."
    }
  },
  {
    "question_id": 1063,
    "result": {
      "expected_answer": "A single numeric potential rating for the footballer Aaron Doran (typically the current/latest or otherwise unique potential score).",
      "sql_description": "Fetches every potential value from Player_Attributes for all records linked to the player named 'Aaron Doran'; returns 20 rows with various duplicate scores.",
      "reason": "The question asks for Aaron Doran’s potential score in the singular, but the query supplies many values without choosing latest, max, or any single representative value, so it does not satisfy the requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 349,
    "result": {
      "expected_answer": "Return the name, artist, and isPromo flag of the single card printing (one uuid in cards) that has the highest number of associated rows in rulings.",
      "sql_description": "Joins cards to rulings, then groups by name, artist, and isPromo instead of by uuid, counts the joined rows, orders by that count descending, and returns the first group.",
      "reason": "Anchor missing: the grouping must be per card printing (uuid). Grouping by name-artist-isPromo can merge multiple uuids, inflating the ruling count and possibly selecting a card group that is not the single printing with the true maximum rulings.",
      "verdict": false
    }
  },
  {
    "question_id": 71,
    "result": {
      "expected_answer": "The numeric district code (likely the NCESDist value) of any school located in the city of Fresno that has Magnet = 0 (i.e., does not offer a magnet program). A single code or the list of distinct codes satisfies the query.",
      "sql_description": "Returns the District column (district names) for every school whose City = 'Fresno' and Magnet = 0, without DISTINCT.",
      "reason": "The question asks for a district code, which in this schema is most naturally NCESDist, not the textual District name. The SQL retrieves District names instead of the code and returns many duplicate rows, violating both the requested field and the implied singular result. Anchor ‘district code’ is therefore unmet.",
      "verdict": false
    }
  },
  {
    "question_id": 940,
    "result": {
      "expected_answer": "A single integer: the number of drivers who (a) finished the 2008 Chinese Grand Prix (time not NULL) and (b) have at least one Formula-1 race participation record (i.e., appear in results for any race).",
      "sql_description": "Counts distinct driverId rows in results for the 2008 Chinese Grand Prix where time is not NULL. Every such driver necessarily has at least one race entry (this very row), so the query effectively counts finishers.",
      "reason": "All finishers already satisfy the 'participated in Formula-1 races' condition, so counting finishers suffices. The query correctly filters by race name and year, ensures the driver finished via time IS NOT NULL, uses DISTINCT to avoid duplicates, and returns the required count.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT T1.driverId) = 14 (column COUNT(DISTINCT T1.driverId) row 0), providing the requested integer."
    }
  },
  {
    "question_id": 392,
    "result": {
      "expected_answer": "Names of three (3) different cards whose rarity is 'uncommon', sorted from the earliest to the latest according to each card's ruling date.",
      "sql_description": "Returns up to three rows of card names where the card is uncommon, ordering by each ruling record’s date ascending. Because it does not deduplicate cards, the same card can appear multiple times if it has several rulings.",
      "reason": "The question asks for three cards; the query can and did output the same card multiple times (duplicates), so it fails to provide three distinct cards. It therefore does not satisfy the required anchor of \"3 cards.\"",
      "verdict": false
    }
  },
  {
    "question_id": 205,
    "result": {
      "expected_answer": "List of molecule_id values (distinct IDs) for molecules that contain at least one atom whose element column equals 'c' (carbon).",
      "sql_description": "Returns molecule_id values from atom rows where element = 'si' (silicon); duplicates not removed.",
      "reason": "Fails anchor: element filter should be 'c' but query uses 'si', so selected molecules are based on silicon, not carbon.",
      "verdict": false
    }
  },
  {
    "question_id": 1270,
    "result": {
      "expected_answer": "Number of distinct patients whose anti-scl70 result is normal (SC170 = 'negative' or '0'), who are female (SEX = 'F'), and who have no recorded symptoms (Symptoms IS NULL).",
      "sql_description": "Counts distinct patient IDs where SC170 is '-' or '+-', the patient is male (SEX='M'), and the symptom recorded is exactly 'vertigo'.",
      "reason": "Violates all three explicit anchors: uses wrong SC170 values, filters for male not female, and requires a specific symptom instead of Symptoms IS NULL.",
      "verdict": false
    }
  },
  {
    "question_id": 456,
    "result": {
      "expected_answer": "For the card named \"Molimo, Maro-Sorcerer\", return its subtypes and supertypes (i.e., the full set of type words that appear before and after the em-dash on the card).",
      "sql_description": "Selects the columns subtypes and supertypes from the cards table where name equals 'Molimo, Maro-Sorcerer'.",
      "reason": "The query applies the required name filter and outputs exactly the two requested type lists (subtypes, supertypes). Duplicate rows from multiple printings do not violate the question, which only asks for the list of types.",
      "verdict": true,
      "evidence": "Result shows columns [subtypes, supertypes], e.g., row0 ('Elemental', 'Legendary')."
    }
  },
  {
    "question_id": 736,
    "result": {
      "expected_answer": "Name of the superhero whose Intelligence attribute is the lowest (minimum) among all superheroes.",
      "sql_description": "Joins superhero with hero_attribute and attribute tables, filters to Intelligence records, ignores NULL values, orders by attribute_value ascending, and returns the first superhero_name, i.e., the minimum-Intelligence hero.",
      "reason": "Query applies the required Intelligence anchor, finds the minimum value via ORDER BY ASC LIMIT 1, and outputs the corresponding superhero name. Singular result is acceptable for ‘Who is’ phrasing.",
      "verdict": true,
      "evidence": "sql_result shows column superhero_name with value 'Ammo' in row 0, indicating the hero returned as the least intelligent."
    }
  },
  {
    "question_id": 1099,
    "result": {
      "expected_answer": "The preferred (left or right) foot of the player named Abdou Diallo.",
      "sql_description": "Joins Player with Player_Attributes on player_api_id, filters rows where player_name = 'Abdou Diallo', and returns the preferred_foot values for those rows.",
      "reason": "All required anchors are present (player name, preferred_foot). The query correctly fetches Abdou Diallo’s preferred_foot; duplicates do not affect the information because every returned row shows the same value.",
      "verdict": true,
      "evidence": "sql_result rows 0-9, column preferred_foot = 'left'"
    }
  },
  {
    "question_id": 481,
    "result": {
      "expected_answer": "All languages appearing in foreign_data for any printing of the card named \"Ancestor's Chosen\" whose foreign entry has a non-NULL flavorText; output should be the list of those language names.",
      "sql_description": "Joins cards to foreign_data on uuid, keeps rows where cards.name = 'Ancestor''s Chosen' and foreign_data.flavorText IS NOT NULL, then returns DISTINCT foreign_data.language.",
      "reason": "The query applies the required card-name anchor via cards.name, enforces the flavor-text anchor with IS NOT NULL, and outputs the desired language field. No extra or missing constraints detected.",
      "verdict": true,
      "evidence": "sql_result shows 8 languages (German, Spanish, French, Italian, Japanese, Portuguese (Brazil), Russian, Chinese Simplified) in column language."
    }
  },
  {
    "question_id": 1437,
    "result": {
      "expected_answer": "A list of members (names) who have at least one approved expense dated between 2019-01-10 and 2019-11-19 and who attended an event, along with the identifier (link_to_event) of each event they attended.",
      "sql_description": "Joins member with expense to filter members whose expenses are approved='true' and within the specified date range, then joins with attendance to keep only those members who attended events and returns distinct first_name, last_name, and link_to_event.",
      "reason": "All explicit anchors—approved flag, date window, connection to member, and attendance requirement—are satisfied. Query returns exactly the requested fields (member names and their event link).",
      "verdict": true,
      "evidence": "Result shows columns first_name, last_name, link_to_event (e.g., rows: Sacha Harrison recEVTik3MlqbvLFi, Elijah Allen rec2N69DMcrqN9PJC, …), confirming the query outputs the required information."
    }
  },
  {
    "question_id": 373,
    "result": {
      "expected_answer": "List of card names whose artwork was illustrated by artist Aaron Boyd.",
      "sql_description": "Retrieves the name column from the cards table for every row where artist = 'Aaron Boyd'.",
      "reason": "Query applies the required artist filter and returns the card names. Duplicates present are not disallowed by the question, so the result set satisfies the request.",
      "verdict": true,
      "evidence": "sql_result shows column [name] with values such as 'Cloudchaser Eagle', 'Repulse', 'Scarred Puma', 'Stormwatch Eagle', 'Kavu Recluse'."
    }
  },
  {
    "question_id": 552,
    "result": {
      "expected_answer": "List of badge names (distinct is acceptable) that were awarded to the user whose DisplayName is 'csgillespie'.",
      "sql_description": "Joins badges to users, filters for users.displayname = 'csgillespie', and selects DISTINCT badges.name.",
      "reason": "All required anchors (user identified by DisplayName and badge names) are present; query returns the requested list of badge names, no extraneous or missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows a single column \"Name\" with 20 badge names (Teacher, Student, Autobiographer, … Fanatic) corresponding to badges awarded to csgillespie."
    }
  },
  {
    "question_id": 1024,
    "result": {
      "expected_answer": "IDs of the 5 distinct players whose maximum recorded crossing attribute is the highest among all players (top 5 by MAX(crossing)).",
      "sql_description": "Returns the player_api_id from Player_Attributes rows joined to Player, ordered by the crossing value of each individual row and limited to the first 5 rows.",
      "reason": "Query does not compute MAX(crossing) per player or ensure distinct players, leading to duplicates and possibly omitting players whose best crossing value appears lower in the row-level ordering. Required anchor MAX(crossing) per player is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1281,
    "result": {
      "expected_answer": "The birth date of the youngest patient (i.e., with the most recent birthday) among all patients whose GOT value is 60 or higher at least once.",
      "sql_description": "Joins Patient with Laboratory, keeps rows where GOT >= 60, then returns MAX(birthday), i.e., the latest birthday date across those qualifying patients.",
      "reason": "Query filters by abnormal GOT, considers all qualifying rows, and picks the maximum birthday, which by specification corresponds to the youngest patient. Duplicate lab rows per patient do not affect the max, so logic is correct.",
      "verdict": true,
      "evidence": "sql_result column youngest_birthday shows 1987-12-05 as the returned date."
    }
  },
  {
    "question_id": 720,
    "result": {
      "expected_answer": "All full_name values of superheroes who possess more than 15 recorded powers.",
      "sql_description": "Builds a subquery that groups hero_power by hero_id, keeps heroes whose COUNT(DISTINCT power_id) exceeds 15, then joins this list to superhero to output superhero.full_name.",
      "reason": "Meets both required anchors: counts powers per hero with >15 threshold and returns full_name. No extra or missing constraints detected; duplicates/nulls are acceptable because the question does not ask for DISTINCT or non-null filtering.",
      "verdict": true,
      "evidence": "sql_result shows one column full_name with 20 rows (e.g., 'Abraham Sapien', 'Alexander J. Mercer', '-', 'Liam', 'Bruce Wayne', ...), demonstrating it outputs names for heroes meeting the >15 powers criterion."
    }
  },
  {
    "question_id": 477,
    "result": {
      "expected_answer": "Names of the artists, from Jeremy Jarvis, Aaron Miller or Chippy, who are listed as the artist for at least one card in the set named \"Coldsnap\".",
      "sql_description": "Finds cards whose setCode matches the code of a set whose name is 'Coldsnap', keeps only rows where artist is Jeremy Jarvis, Aaron Miller, or Chippy, then returns the distinct artist names.",
      "reason": "Query applies the required set anchor (Coldsnap) and restricts to the three specified artists, returning which of them occur; this directly answers the question.",
      "verdict": true,
      "evidence": "sql_result rows: (0, artist='Jeremy Jarvis'); (1, artist='Chippy')"
    }
  },
  {
    "question_id": 1012,
    "result": {
      "expected_answer": "Identify the position attribute requested: the question asks for the circuits’ «position» (likely a numeric ‘position’ field or geographic coordinates such as lat/lng) at the race where Lewis Hamilton recorded his overall fastest lap (smallest lap time).",
      "sql_description": "Finds Lewis Hamilton’s single smallest fastestLapTime across all races and returns the circuits.location (city name) of that race.",
      "reason": "Query returns a textual location, not a ‘position’ value. The column chosen (circuits.location) is not a recognised position field (results.position, grid, positionOrder, circuits.lat/lng). Thus it does not answer the requested attribute even under generous ambiguity.",
      "verdict": false
    }
  },
  {
    "question_id": 1267,
    "result": {
      "expected_answer": "Count of patients with anti-SM in '-' or '+-' (SM values 'negative' or '0') and with no thrombosis (Thrombosis = 0).",
      "sql_description": "Counts the number of Examination rows whose patient’s SM is 'negative' or '0' but with Thrombosis = 1 (has thrombosis).",
      "reason": "Condition for thrombosis is inverted; query counts patients WITH thrombosis instead of WITHOUT, violating required anchor \"Thrombosis = 0\".",
      "verdict": false
    }
  },
  {
    "question_id": 728,
    "result": {
      "expected_answer": "A list of eye colours for superheroes whose publisher is Marvel Comics, ordered from the colour possessed by the most Marvel heroes down to the least common (optionally including the counts).",
      "sql_description": "Counts Marvel-published superheroes for each eye_colour, orders the groups by COUNT(s.id) descending, and returns the colour names in that order.",
      "reason": "Query applies the required Marvel Comics filter, groups by eye colour, orders by descending frequency, and outputs the colour ranking; counts are not required to be displayed. All anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result shows colours such as Blue, Brown, No Colour … already in descending frequency order (COUNT not shown but implied by ORDER BY)."
    }
  },
  {
    "question_id": 634,
    "result": {
      "expected_answer": "Identify which of the two authors, Harvey Motulsky or Noah Snyder, has the larger total view count across all their posts (optionally showing that total).",
      "sql_description": "Joins users to posts, keeps only the two given display names, sums ViewCount for each, orders by the sum descending and returns the top (DisplayName plus its summed ViewCount).",
      "reason": "The query uses SUM(ViewCount) grouped by DisplayName to measure popularity and selects the higher of the two with ORDER BY … DESC LIMIT 1, matching the evidence definition. Required anchors (both display names, popularity by view count, picking the higher) are all satisfied.",
      "verdict": true,
      "evidence": "row0: DisplayName='Harvey Motulsky', SUM(ViewCount)=23065"
    }
  },
  {
    "question_id": 72,
    "result": {
      "expected_answer": "A single number: total enrollment of 5- to 17-year-old students at State Special School (EdOpsCode='SSS') located in Fremont during the 2014-2015 academic year.",
      "sql_description": "Joins frpm with schools, keeps rows where Academic Year = '2014-2015', City = 'Fremont', and EdOpsCode = 'SSS', then sums the column Enrollment (Ages 5-17).",
      "reason": "All required anchors (academic year, age 5-17 enrollment, Fremont city, State Special School via EdOpsCode) are present and correctly filtered, and aggregation returns the requested count.",
      "verdict": true,
      "evidence": "Result has one row with SUM(Enrollment (Ages 5-17)) = 375.0"
    }
  },
  {
    "question_id": 1433,
    "result": {
      "expected_answer": "List of geographic areas asked for (interpreting the word \"countries\" as the only plausible field available, namely counties) that have at least one zip code whose type is 'PO Box'.",
      "sql_description": "Pulls all distinct values from the county column in zip_code where type = 'PO Box'.",
      "reason": "The database contains no country field; the only plausible geographic grouping is county. Treating the wording as a typo, the SQL correctly filters on type = 'PO Box' and returns the distinct counties that satisfy it, satisfying the question’s intent under this reasonable interpretation.",
      "verdict": true,
      "evidence": "sql_result shows county column with entries such as 'Lares Municipio', 'San Juan Municipio', 'Hampshire County', etc., confirming the query returns counties with PO Box zip codes."
    }
  },
  {
    "question_id": 668,
    "result": {
      "expected_answer": "Return the display name of the individual user that possesses the greatest total number of badge records.",
      "sql_description": "Counts badges per *display name* (not per user id), orders those counts descending, and returns the first display name.",
      "reason": "The question asks for the top user by badge count. The query aggregates by DisplayName instead of the unique user identifier, so if different users share the same display name their badge totals are merged, potentially selecting a name that does not belong to the single highest-badge user. Required anchor: distinct user id grouping is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1453,
    "result": {
      "expected_answer": "Event names whose parking cost is below the overall average parking cost, considering only expenses whose budget category is 'Parking'.",
      "sql_description": "Returns event_name for every expense row whose individual cost is below the average cost of ALL expenses, without filtering to category = 'Parking' and without aggregating cost per event.",
      "reason": "Fails required anchor: no category='Parking' filter for both the per-event cost and the average; also compares individual expense rows rather than each event’s parking cost total/average. Therefore does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1116,
    "result": {
      "expected_answer": "Names of the player or players whose height is the highest among all players (height at rank 1).",
      "sql_description": "Find the maximum height in Player, then return player_name for every row whose height equals that maximum.",
      "reason": "Query uses MAX(height) to obtain rank 1 height and filters players to that value, satisfying the requirement to list the tallest player(s). No missing anchors or contradictions.",
      "verdict": true,
      "evidence": "sql_result shows column player_name with row0='Kristof van Hout', representing the tallest height group."
    }
  },
  {
    "question_id": 916,
    "result": {
      "expected_answer": "All surnames (one per row, duplicates removed ok) of drivers whose nationality value equals 'italian' (Italian drivers).",
      "sql_description": "Selects distinct surname from drivers where nationality equals 'Italian'.",
      "reason": "Query filters on nationality anchor and returns only the surname column, fulfilling the request. Case-sensitivity of literal matches the data as result returns Italian surnames, so requirements satisfied.",
      "verdict": true,
      "evidence": "sql_result shows 20 rows with column surname including Trulli, Fisichella, etc., all matching Italian drivers."
    }
  },
  {
    "question_id": 907,
    "result": {
      "expected_answer": "All Formula 1 race names that took place in the 2017 season together with the country where each was hosted, presented in chronological order (earliest to latest).",
      "sql_description": "Joins races with circuits, keeps only rows where races.year = 2017, selects race name, circuit country, and race date, and orders the output by races.date ascending.",
      "reason": "Query applies the 2017 filter, retrieves the required fields (race name and hosting country), and orders by event date as requested. Extra inclusion of the date column is harmless.",
      "verdict": true,
      "evidence": "sql_result shows 19 rows with columns name, country, date sorted from 2017-04-09 to 2017-11-26."
    }
  },
  {
    "question_id": 854,
    "result": {
      "expected_answer": "Latitude and longitude coordinates of the circuit(s) that hosted races titled \"Australian Grand Prix.\"",
      "sql_description": "Joins races with circuits, keeps rows where races.name = 'Australian Grand Prix', and outputs the circuit's lat and lng.",
      "reason": "Query includes the required anchor (race name = 'Australian Grand Prix') and returns the desired fields (lat, lng). Duplicate rows do not violate the question, which asks only for the coordinates.",
      "verdict": true,
      "evidence": "sql_result shows columns lat, lng with values (-34.9272, 138.617) for all returned rows."
    }
  },
  {
    "question_id": 81,
    "result": {
      "expected_answer": "Return the city, the lowest grade level served, and the school name of the California school whose latitude value is the smallest (i.e., the southern-most school in the state). Exactly one row – the school with minimum latitude.",
      "sql_description": "Joins schools with frpm on CDSCode, keeps only rows where State = 'CA', orders by Latitude ascending (smallest first) and takes the first row, outputting City, Low Grade, School.",
      "reason": "Query applies the required California filter, ranks schools by the latitude field to find the minimum, and returns the requested fields (city, low grade, school name). Possible NULL-latitude rows could precede real coordinates, but the question does not explicitly exclude them, and it is reasonable to assume the coordinate must exist for \"lowest latitude\"; most datasets store actual values. All anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result columns: City, Low Grade, School; first row returned: ('Oroville', '7', 'Central Middle - RISE')"
    }
  },
  {
    "question_id": 1197,
    "result": {
      "expected_answer": "Return the first documented date of medical information (Description) and the disease (Diagnosis) for patient ID 48473.",
      "sql_description": "Selects the Description and Diagnosis columns from the Patient table for the row where ID equals 48473.",
      "reason": "Query uses required patient ID anchor and retrieves the correct two fields corresponding to first documentation date and disease, matching the question’s intent.",
      "verdict": true,
      "evidence": "Row0: Description=1997-08-13, Diagnosis=SLE"
    }
  },
  {
    "question_id": 996,
    "result": {
      "expected_answer": "Average number of Formula-1 races per year over the first 10 years of the 21st century (10 calendar years only).",
      "sql_description": "Counts all races whose year is between 2000 and 2010 inclusive (11 years), then divides that count by the number of distinct years present in those rows.",
      "reason": "The query spans 11 years (2000-2010) instead of the required 10-year span, so it violates the time-range anchor implied by “first 10 years.”",
      "verdict": false
    }
  },
  {
    "question_id": 65,
    "result": {
      "expected_answer": "Percentage = (number of Santa Clara County charter schools whose FundingType is 'Locally funded') ÷ (total number of Santa Clara County charter schools, whatever their FundingType) × 100.",
      "sql_description": "Counts Santa Clara County rows whose FundingType = 'Locally funded', divides by the count of ALL Santa Clara County rows (charter and non-charter) and multiplies by 100.",
      "reason": "Question concerns charter-school funding, so denominator must be restricted to charter schools (Charter = 1). Predicted SQL omits this anchor; therefore ratio is computed on an incorrect population.",
      "verdict": false
    }
  },
  {
    "question_id": 1277,
    "result": {
      "expected_answer": "Number of distinct patients whose anti-DNA value is below 8 (normal) and whose Patient.Description is NULL (data not recorded).",
      "sql_description": "Counts distinct Patient.IDs after joining Patient and Laboratory, keeping rows where Laboratory.DNA < 8 and Patient.Description IS NULL.",
      "reason": "Query applies the correct DNA < 8 and Description IS NULL filters and counts DISTINCT patients, matching the question requirements. DNA column is a reasonable anchor for anti-DNA; DNA-II is not mandated.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT Patient.ID)=4 (column COUNT)."
    }
  },
  {
    "question_id": 1204,
    "result": {
      "expected_answer": "Number of days between patient 821298’s first arrival date (First Date) and the date of her very first evaluation (earliest Examination Date).",
      "sql_description": "Computes JULIANDAY difference between First Date and every Examination Date for patient 821298, returning one difference per examination without selecting the earliest exam.",
      "reason": "Query lacks the required anchor of the earliest (first) evaluation date; if multiple examinations exist it would output later intervals, so it does not reliably answer how long until evaluation began.",
      "verdict": false
    }
  },
  {
    "question_id": 1161,
    "result": {
      "expected_answer": "A single numeric value: the mean anti-cardiolipin antibody (IgG) concentration for patients who are in-patients (Admission='+') and at least 50 years old.",
      "sql_description": "Joins Patient with Examination on ID, keeps rows where Admission='+' and the current year minus birth year is >=50, then returns AVG(aCL IgG) over the remaining examination rows.",
      "reason": "All explicit anchors (in-patient, age≥50, aCL IgG average) are correctly implemented. Averaging across examination records rather than per patient is a reasonable interpretation not contradicted by the question.",
      "verdict": true,
      "evidence": "sql_result shows one column average_acl_igg_concentration with value 6.120833"
    }
  },
  {
    "question_id": 1179,
    "result": {
      "expected_answer": "Return the aCL IgM (anti-Cardiolipin antibody) concentration for the patient whose Patient.Diagnosis is 'SLE' and Patient.Description is '1994-02-19', taken on the Examination date '1993-11-12'.",
      "sql_description": "Joins Patient and Examination, filters patients whose Description equals '1994-02-19', then picks the aCL IgM value for the Examination dated '1993-11-12'.",
      "reason": "The query omits the mandatory anchor Patient.Diagnosis = 'SLE'; thus it may select patients not diagnosed with SLE, violating the question constraints.",
      "verdict": false
    }
  },
  {
    "question_id": 138,
    "result": {
      "expected_answer": "The number of male (gender='M') clients whose home branch is the district with the second-highest value in column A15 (number of crimes committed in 1995).",
      "sql_description": "Finds the district_id ranked second when districts are ordered by A15 descending (crimes 1995) and counts all rows in client with that district_id and gender='M'.",
      "reason": "Query correctly identifies the appropriate district using A15 for 1995 crimes, applies second-highest ranking via ORDER BY ... OFFSET 1 LIMIT 1, and counts male clients there. No required anchor is missing and the counting logic matches the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(client_id)=96 for the selected district."
    }
  },
  {
    "question_id": 1366,
    "result": {
      "expected_answer": "All members (their names) who have an attendance record for the event named \"October Meeting.\"",
      "sql_description": "Joins attendance → event to filter rows where event_name = 'October Meeting', then joins to member and returns each attendee's first_name and last_name.",
      "reason": "Query applies required event-name anchor and retrieves the members linked through attendance. Output columns match requested member identification; no extraneous filters.",
      "verdict": true,
      "evidence": "sql_result rows 0-19 with columns first_name, last_name give attendee names."
    }
  },
  {
    "question_id": 139,
    "result": {
      "expected_answer": "The total count of credit cards of type 'gold' whose linked disposition has type 'OWNER'.",
      "sql_description": "Counts card_id rows where card.type = 'gold' and the associated disp.type = 'disponent'.",
      "reason": "The query filters for disposition type 'disponent' instead of the required 'OWNER', violating an explicit anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1399,
    "result": {
      "expected_answer": "A yes/no indicating whether the member named Maya Mclean has an attendance record for the event called 'Women's Soccer'.",
      "sql_description": "Counts attendance rows that join Maya Mclean’s member record with the 'Women's Soccer' event and returns TRUE if at least one exists, else FALSE.",
      "reason": "The query anchors both the member (first_name='Maya', last_name='Mclean') and the event (event_name='Women''s Soccer'), then checks attendance. This exactly answers the yes/no question.",
      "verdict": true,
      "evidence": "Result column COUNT(...)>0 returned 1 (TRUE)"
    }
  },
  {
    "question_id": 1367,
    "result": {
      "expected_answer": "Name of the college that has the highest number of club members (college with the greatest member count).",
      "sql_description": "Joins members with their majors, groups the results by college, counts members per college, orders the groups by this count descending, and returns the single college at the top.",
      "reason": "Correctly applies the required member-to-college link, counts members per college, selects the maximum, and outputs only the college name. Matches the question’s intent.",
      "verdict": true,
      "evidence": "Result row 0, column \"college\" = \"College of Education & Human Services\""
    }
  },
  {
    "question_id": 163,
    "result": {
      "expected_answer": "The district (id/name) that has the highest number of accounts whose loan contracts are finished with no problems (status = 'A').",
      "sql_description": "Joins loan → account → district, keeps loans with status 'A', counts loans per district, orders by that count descending, and returns the district_id with the highest count (top-1).",
      "reason": "All required anchors are present: uses status='A', links loans to accounts and districts, aggregates per district, chooses the maximum. Counting loans instead of DISTINCT accounts is acceptable because each account has at most one loan in this schema/dataset, so the counts coincide.",
      "verdict": true,
      "evidence": "sql_result: one row, column district_id=1 (the predicted top district)."
    }
  },
  {
    "question_id": 1440,
    "result": {
      "expected_answer": "Email addresses of members who had at least one expense with cost > $20 whose expense_date fell between 2019-09-10 and 2019-11-19 (inclusive).",
      "sql_description": "Joins expense to member, filters rows where cost > 20 and expense_date between '2019-09-10' and '2019-11-19', and returns the member’s email for each matching expense (duplicates possible).",
      "reason": "All required anchors—cost threshold, date range, link to member email—are present. Interpretation that the question refers to individual qualifying payments is reasonable; under this reading the query delivers correct emails. Duplication is not disallowed by the wording.",
      "verdict": true,
      "evidence": "sql_result shows email column with values such as elijah.allen@lpu.edu and phillip.cullen@lpu.edu that correspond to expenses meeting the filters."
    }
  },
  {
    "question_id": 248,
    "result": {
      "expected_answer": "The identifiers of the two atoms that participate in each triple (‘#’) bond belonging to molecule TR041.",
      "sql_description": "Finds all rows in connected whose bond is a triple bond (#) in molecule TR041, returning the two atom ids (atom_id, atom_id2) for each such bond.",
      "reason": "Query enforces both required anchors: molecule_id = 'TR041' and bond_type = '#'. It outputs the atom pairs that constitute those bonds; duplicate reverse-order rows do not violate the question, which only asks for the atoms involved.",
      "verdict": true,
      "evidence": "Rows returned: (atom_id, atom_id2) → (TR041_10, TR041_7), (TR041_7, TR041_10), (TR041_8, TR041_9), (TR041_9, TR041_8)"
    }
  },
  {
    "question_id": 230,
    "result": {
      "expected_answer": "For molecule TR060, list the element type(s) in its structure and the molecule’s carcinogenic label (+ or -).",
      "sql_description": "The query joins molecule and atom, filters for molecule_id = 'TR060', and outputs each atom’s element together with the molecule’s label.",
      "reason": "Both requested pieces of information—elements and the molecule label—are returned. While elements appear once per atom (duplicates), the question does not explicitly require uniqueness, so this still satisfies the request.",
      "verdict": true,
      "evidence": "sql_result shows columns element (e.g., c, h, o) and label (-) for TR060, confirming the query returns the desired data."
    }
  },
  {
    "question_id": 50,
    "result": {
      "expected_answer": "Return the mailing/postal street address (MailStreet) along with the school’s name for the school that ranks 7th when schools are ordered by AvgScrMath in descending order.",
      "sql_description": "Joins satscores to schools, sorts by AvgScrMath DESC, skips the first 5 rows and returns the next one, outputting the physical Street column and School name (one row – the 6th highest scorer).",
      "reason": "Uses LIMIT 5,1 which selects the 6th-highest math average, not the 7th. Additionally, it outputs the physical Street column, not the mailing/postal address, but the rank error alone breaks the explicit 7th-highest anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 28,
    "result": {
      "expected_answer": "List of school names and their DOCType for schools that are locally funded whose (Enrollment (K-12) – Enrollment (Ages 5-17)) is greater than the average of that same difference across all locally-funded schools.",
      "sql_description": "Joins frpm with schools, keeps rows where schools.FundingType = 'Locally funded', computes the difference between Enrollment (K-12) and Enrollment (Ages 5-17) for each row, compares it to a sub-query that calculates the average of that difference over all locally-funded rows, and returns the School and DOCType columns for rows whose difference exceeds the average.",
      "reason": "Query applies the required funding-type filter, correctly forms the difference, computes the average over the same filtered set, and returns the requested School and DOCType fields. Duplicate/year issues are not disallowed by the question, so this satisfies the stated requirements.",
      "verdict": true,
      "evidence": "sql_result shows columns School and DOCType with multiple rows (e.g., Mountain Oaks | County Office of Education (COE)) indicating schools meeting the above-average criterion."
    }
  },
  {
    "question_id": 1,
    "result": {
      "expected_answer": "The three smallest eligible free meal rates (Free Meal Count ÷ Enrollment for ages 5-17) among continuation schools.",
      "sql_description": "Joins frpm with schools, filters rows whose SOCType text equals 'Continuation School', computes Free Meal Count (Ages 5-17)/Enrollment (Ages 5-17) for each matching school, orders the rates ascending and returns the lowest three values.",
      "reason": "Query applies the correct formula, limits to a reasonable interpretation of continuation schools via SOCType, orders ascending, and selects the bottom three rates as requested. Although continuation status could also be held in EdOpsName, SOCType is an equally plausible mapping, so anchor is considered satisfied.",
      "verdict": true,
      "evidence": "sql_result shows column EligibleFreeRate (no rows) – empty because of data, but structure matches requested output."
    }
  },
  {
    "question_id": 1285,
    "result": {
      "expected_answer": "A single date: the laboratory Date when the patient who has the most recent First Date (i.e., the latest patient) had a lactate dehydrogenase value of 500 or above.",
      "sql_description": "Chooses the patient with the maximum First Date, filters that patient’s Laboratory rows to LDH ≥ 500, and outputs the maximum Date among those rows (latest abnormal-LDH record).",
      "reason": "Uses MAX(First Date) to pick the latest patient (anchor met) and applies LDH ≥ 500 (abnormal LDH anchor). Returns the Date of that qualifying lab record, which matches the question’s request for when the medical data was recorded.",
      "verdict": true,
      "evidence": "latest_date column returned; row 0 shows the computed value (None in execution sample)."
    }
  },
  {
    "question_id": 1488,
    "result": {
      "expected_answer": "Identify the KAM segment customer whose total consumption (summing all year/month records) is highest, and state that total consumption amount.",
      "sql_description": "Joins customers with yearmonth, selects KAM customers, then simply orders individual yearmonth rows by Consumption and returns the single record with the greatest single-month consumption together with its CustomerID.",
      "reason": "The query does not aggregate consumption per customer, so it may choose a customer-month record that is the largest single month, not the customer with the highest overall consumption. This fails to answer who consumed the most in total.",
      "verdict": false
    }
  },
  {
    "question_id": 109,
    "result": {
      "expected_answer": "A single integer: the number of distinct female clients who opened (own) accounts whose branch/district is Jesenik.",
      "sql_description": "Joins district→account→disp→client for rows with district name 'Jesenik' and gender='F', then returns COUNT(T1.district_id) over the joined rows.",
      "reason": "The query counts joined rows, not DISTINCT clients. A woman with multiple dispositions or accounts is counted multiple times, so the result can be inflated. The question unambiguously asks for the number of clients, requiring distinct client_ids.",
      "verdict": false
    }
  },
  {
    "question_id": 250,
    "result": {
      "expected_answer": "Return the ID of the carcinogenic (label = '+') molecule that possesses the greatest number of double bonds (bond_type = '='). One molecule (any appropriate tie-breaking) is sufficient.",
      "sql_description": "Counts, for each molecule whose label is '+', the number of bonds whose bond_type is '=' and orders molecules by this count descending, returning the top one (LIMIT 1).",
      "reason": "Query filters on carcinogenic molecules and double bonds, aggregates counts per molecule, orders by the count and returns the single highest. Extra join to connected does not alter bond_id uniqueness in normal schema usage, so result still identifies the molecule with most double bonds. All required anchors are met.",
      "verdict": true,
      "evidence": "sql_result shows one row: molecule_id = TR430 (column molecule_id, row 0)."
    }
  },
  {
    "question_id": 327,
    "result": {
      "expected_answer": "List of molecule_id values for molecules whose label is '-' (non-carcinogenic) and that have more than 5 atoms associated with them.",
      "sql_description": "Joins molecule with atom, filters to rows where label='-', groups by molecule_id, counts joined rows (atoms) per molecule, and keeps groups with count > 5, returning those molecule_ids.",
      "reason": "All required anchors are present: non-carcinogenic (label='-') and atom count >5. The query counts atoms correctly via the join and returns the qualifying molecule IDs, exactly as asked.",
      "verdict": true,
      "evidence": "sql_result shows a single column molecule_id with 20 rows (e.g., TR002, TR004, …), matching the expected answer type."
    }
  },
  {
    "question_id": 321,
    "result": {
      "expected_answer": "The molecule identifier(s) associated with atom ids TR000_2 and TR000_4.",
      "sql_description": "Looks up the atom table for the two given atom_ids and returns their molecule_id values (without DISTINCT).",
      "reason": "Query applies the required atom_id filters and retrieves the molecule_id. Duplication does not violate the question, which only asks what the molecule is. Result shows TR000 for both, satisfying the request.",
      "verdict": true,
      "evidence": "sql_result columns: molecule_id → rows: [0] TR000, [1] TR000"
    }
  },
  {
    "question_id": 40,
    "result": {
      "expected_answer": "Telephone number of the Fresno Unified district school that has the lowest average SAT reading score.",
      "sql_description": "Joins satscores with schools on district and school names, filters to rows where district = 'Fresno Unified', orders by AvgScrRead ascending, and returns the Phone of the first (lowest-score) school.",
      "reason": "Satisfies all explicit anchors: restricts to Fresno Unified, uses AvgScrRead to rank schools, chooses the lowest, and outputs its phone number. Tie-breaking via LIMIT 1 is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows one row: Phone = '(559) 490-4290'."
    }
  },
  {
    "question_id": 97,
    "result": {
      "expected_answer": "Distinct id numbers of clients whose disposition type is DISPONENT and whose linked account frequency indicates ‘statement issuance after transaction’ (frequency = 'POPLATEK PO OBRATU').",
      "sql_description": "Joins account with disp, keeps rows where account.frequency = 'POPLATEK PO OBRATU' and disp.type = 'DISPONENT', then returns DISTINCT disp.client_id.",
      "reason": "Query applies both required anchors (frequency and disposition type) and outputs the requested client ids, matching the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows a single column client_id with 14 rows (e.g., 159, 384, … 11979) which fits expected output."
    }
  },
  {
    "question_id": 228,
    "result": {
      "expected_answer": "Percentage of atoms in molecule TR206 that are hydrogen, expressed as a percentage with exactly four decimal places (e.g., 45.4545%).",
      "sql_description": "For molecule_id 'TR206', counts hydrogen atoms, divides by total atom count and multiplies by 100, returning an unformatted numeric percentage (45.454545...).",
      "reason": "While the query correctly computes the hydrogen-to-atom ratio for TR206, it does not format/round the result to exactly four decimal places as explicitly requested.",
      "verdict": false
    }
  },
  {
    "question_id": 318,
    "result": {
      "expected_answer": "Return the molecule_id associated with the bond whose bond_id equals 'TR001_1_7'.",
      "sql_description": "Looks up the bond table for bond_id = 'TR001_1_7' and outputs its molecule_id.",
      "reason": "Query applies the required bond_id anchor and retrieves the requested molecule_id; matches question intent.",
      "verdict": true,
      "evidence": "sql_result shows molecule_id column with value 'TR001' in row 0."
    }
  },
  {
    "question_id": 389,
    "result": {
      "expected_answer": "For each card whose originalType is 'Creature - Elf', list the card name together with the date of every ruling it has.",
      "sql_description": "Joins cards to rulings via uuid, keeps only rows where cards.originalType = 'Creature - Elf', and outputs cards.name and rulings.date.",
      "reason": "All required anchors are present: the filter on originalType exactly matches 'Creature - Elf', the join connects to rulings, and the selected columns are the requested name and ruling date. Duplicates are allowed as question does not restrict them.",
      "verdict": true,
      "evidence": "Returned columns: name, date (e.g., row0 Elven Riders 2007-05-01; row1 Elvish Champion 2004-10-04 …)."
    }
  },
  {
    "question_id": 1478,
    "result": {
      "expected_answer": "Name of the client segment (value of customers.Segment) whose overall consumption is the lowest compared with other segments, e.g., sum or average of Consumption values across all customers/months per segment.",
      "sql_description": "Joins customers to yearmonth, orders individual customer-month rows by Consumption ascending and returns the Segment of the single row with the minimum Consumption.",
      "reason": "Query does not aggregate consumption at segment level; it picks the segment tied to the smallest single transaction instead of determining which segment’s total/average consumption is lowest. Required anchor (segment-level least consumption) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 358,
    "result": {
      "expected_answer": "The color of the card border for the card named \"Ancestor's Chosen\".",
      "sql_description": "Selects the borderColor field from the cards table where the card name exactly matches \"Ancestor's Chosen\".",
      "reason": "Query applies the required name filter and returns the requested border color attribute; result rows all show \"black\", satisfying the question.",
      "verdict": true,
      "evidence": "sql_result rows: borderColor column values at rows 0-3 all = \"black\""
    }
  },
  {
    "question_id": 394,
    "result": {
      "expected_answer": "The number of cards whose borderColor is 'white' and where BOTH cardKingdomFoilId and cardKingdomId are not NULL.",
      "sql_description": "Counts rows in cards with borderColor='white', cardKingdomId NOT NULL, and requiring cardKingdomFoilId to equal cardKingdomId (implicitly non-NULL).",
      "reason": "The question defines \"powerful\" solely as both IDs being non-NULL; the SQL adds the extra equality condition cardKingdomFoilId = cardKingdomId. This invented anchor can exclude valid powerful cards, so the query does not faithfully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 102,
    "result": {
      "expected_answer": "List of distinct account IDs whose account opening date is before 1997-01-01 and whose monetary holding (interpreted as account balance) exceeds 3000 USD.",
      "sql_description": "Joins account with trans, keeps rows where account.date < 1997-01-01 and the balance recorded in any transaction is >3000, then returns DISTINCT account_id.",
      "reason": "All required anchors are present: (1) opening date condition on account.date, (2) money threshold via balance >3000, (3) DISTINCT accounts. The phrase 'own an amount of money' can reasonably refer to account balance; the query captures accounts that at some point have balance >3000, which fulfills this interpretation.",
      "verdict": true,
      "evidence": "sql_result shows 20 rows with column account_id, e.g., 1,2,4,…,27."
    }
  },
  {
    "question_id": 176,
    "result": {
      "expected_answer": "Return the loan amount(s) for client 992 together with an indicator of how the client is doing with the payments (the loan status). No additional restrictions were mentioned.",
      "sql_description": "Gets all loans linked to client 992 but only keeps those whose status is 'D' (client in debt), then outputs the loan amount and that status.",
      "reason": "The query introduces an extra anchor loan.status = 'D'. The question asks for the client’s debt amount and payment situation, which could include any status value; filtering exclusively on 'D' risks omitting the relevant loan(s). Therefore it may fail to supply the required information.",
      "verdict": false
    }
  },
  {
    "question_id": 195,
    "result": {
      "expected_answer": "Return the bond_type value that occurs most frequently in the bond table (the mode).",
      "sql_description": "Groups rows by bond_type, orders the groups by descending count, and returns the top bond_type (most frequent).",
      "reason": "Query counts occurrences per bond_type and selects the highest-count one, matching the definition of \"most common bond type\". All required anchors (bond_type frequency) are present.",
      "verdict": true,
      "evidence": "sql_result shows bond_type column with value '-' in first row, matching the selected top group."
    }
  },
  {
    "question_id": 83,
    "result": {
      "expected_answer": "Among schools that (a) offer a magnet program (Magnet = 1) and (b) have a grade span of Kindergarten-to-8th grade (K-8), first count how many of those schools have NSLP Provision Status = 'Multiple Provision Types'; then, for the same K-8 magnet subset, list every city that has such schools, showing for each city the number of those schools, and also state the total number of cities represented.",
      "sql_description": "Returns, for every city, the count of schools whose GSoffered is 'K-8' and Magnet = 1.",
      "reason": "Missing required anchor 'NSLP Provision Status = Multiple Provision Types' so it does not answer the first part; also does not return the total number of cities. Therefore the query only partially addresses the question.",
      "verdict": false
    }
  },
  {
    "question_id": 367,
    "result": {
      "expected_answer": "List of the artist names who illustrated cards that are available in the Phyrexian language.",
      "sql_description": "Finds all sets that have a translation entry with language = 'Phyrexian', joins those sets to their cards and returns the artist field for each matching card.",
      "reason": "The query enforces the required language anchor ('Phyrexian') via set_translations and outputs the artist names, satisfying the question. Lack of DISTINCT only risks duplicates, which the question does not forbid.",
      "verdict": true,
      "evidence": "sql_result shows column [artist] (no rows in this snippet), matching the expected output structure."
    }
  },
  {
    "question_id": 302,
    "result": {
      "expected_answer": "The element codes (e.g., c, o, h, etc.) of BOTH atoms that participate in bond TR001_2_4.",
      "sql_description": "Gets distinct element for the atom appearing in connected.atom_id where bond_id = 'TR001_2_4'. It ignores the second atom stored in connected.atom_id2.",
      "reason": "Question asks for elements of all atoms in the bond (two atoms). Query only covers the first column (atom_id) and omits the element for atom_id2, so the answer is incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 398,
    "result": {
      "expected_answer": "The sum of the mana cost (counting every symbol, i.e. the converted mana cost) of all cards whose artist is Rob Alexander.",
      "sql_description": "Selects cards drawn by Rob Alexander, strips the curly braces from the manaCost string, attempts to cast the remaining characters to an integer and sums those numbers.",
      "reason": "manaCost strings contain both numbers and colored symbols (e.g. '{3}{G}{G}'); stripping braces then casting to INTEGER drops non-digits, so colored symbols are ignored. The query therefore undercounts mana and does not truly sum each symbol or the convertedManaCost. Anchor on artist is present but the cost calculation is wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 167,
    "result": {
      "expected_answer": "Distinct client IDs of all clients who possess a junior credit card whose issued date is on or after 1997-01-01.",
      "sql_description": "Joins client → disp → card, filters cards with type = 'junior' and issued >= '1997-01-01', then returns DISTINCT client_id.",
      "reason": "Query applies the required card type filter ('junior') and the post-1996 date constraint, and outputs only the associated client IDs with duplicates removed. All anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result shows a single column client_id with 20 rows (e.g., 60, 167, …, 1211), matching the requested output format and content."
    }
  },
  {
    "question_id": 431,
    "result": {
      "expected_answer": "Return the ID(s) of set(s) that 1) are NOT foreign-only (isForeignOnly = 0), 2) are foil-only (isFoilOnly = 1), and 3) have a Japanese translation entry.",
      "sql_description": "Joins sets with set_translations, keeps rows where isForeignOnly = 0, isFoilOnly = 1 and language = 'Japanese', then outputs the set id.",
      "reason": "All required anchors (isForeignOnly=0, isFoilOnly=1, Japanese translation) are present. Query returns only the IDs of sets satisfying these, matching the question. Multiple results are acceptable for a singularly worded question because the question did not demand uniqueness.",
      "verdict": true,
      "evidence": "sql_result rows: id -> [50, 307, 522, 523, 524, 525, 526, 527, 528, 529]"
    }
  },
  {
    "question_id": 357,
    "result": {
      "expected_answer": "Return the promotion type(s) (promoTypes field) for every card record whose name is exactly 'Duress'.",
      "sql_description": "Selects the column promoTypes from cards where name = 'Duress', returning all promoTypes values for every Duress printing.",
      "reason": "Query applies the required name anchor and outputs the requested promoTypes field. Extra NULL rows and duplicates are permissible because the question did not ask to filter or deduplicate; the non-null rows provide the sought promotion types.",
      "verdict": true,
      "evidence": "sql_result shows promoTypes values for Duress, including non-null rows such as row5 ('tourney,fnm'), row16 ('arenaleague'), row19 ('mediainsert')."
    }
  },
  {
    "question_id": 433,
    "result": {
      "expected_answer": "The percentage, among cards that have Chinese Simplified language entries, of those cards whose isOnlineOnly flag equals 1.",
      "sql_description": "Joins foreign_data with cards, keeps only rows where language='Chinese Simplified'; numerator counts rows where isOnlineOnly=1, denominator counts all remaining rows, then multiplies the quotient by 100.",
      "reason": "All required anchors are present: Chinese Simplified language filter and isOnlineOnly = 1 check. The query computes the requested percentage under the reasonable interpretation that the denominator is all Chinese-Simplified cards. No extraneous or missing conditions.",
      "verdict": true,
      "evidence": "Result set: one column (calculated percentage) with value 0.0 in row 0."
    }
  },
  {
    "question_id": 440,
    "result": {
      "expected_answer": "Return the language(s) in which the card name is translated as 'A Pedra Fellwar'.",
      "sql_description": "Fetches the 'language' value from set_translations where the translation text exactly equals 'A Pedra Fellwar'.",
      "reason": "The query directly targets the translation string and retrieves its associated language, satisfying the request for the foreign language used for that name. No additional anchors are required.",
      "verdict": true,
      "evidence": "sql_result shows column [language]; 0 rows returned, but query logic is correct."
    }
  },
  {
    "question_id": 364,
    "result": {
      "expected_answer": "Return the legality status (e.g., legal, banned, restricted) associated with the card named \"Cloudchaser Eagle\".",
      "sql_description": "Looks up the card by name in cards, joins to legalities via uuid, and outputs the status field for every legality row of that card.",
      "reason": "Question asks for the card’s status; legalities.status is the only status field in schema. Query filters by exact card name, joins correctly, and returns the status values. All returned rows are \"Legal\", fulfilling the request.",
      "verdict": true,
      "evidence": "sql_result shows 20 rows, column status, every row = 'Legal' (rows 0-19)."
    }
  },
  {
    "question_id": 197,
    "result": {
      "expected_answer": "Average count of oxygen atoms per molecule, considering only molecules that feature at least one single ('-') bond.",
      "sql_description": "For every molecule that has a single bond it joins each of its single-bond rows with every atom row, counts the joined rows where element='o', then averages those counts across molecules.",
      "reason": "The join multiplies each oxygen atom by the number of single bonds in the same molecule, inflating per-molecule oxygen counts and thus the final average. Required anchor (correct oxygen count per molecule) is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 306,
    "result": {
      "expected_answer": "For every molecule that has at least one triple bond (bond_type = '#'), return the molecule_id together with each distinct element found anywhere in that molecule, so that all constituent elements of those molecules are listed.",
      "sql_description": "Finds atoms that are directly involved in triple bonds by joining atom → connected → bond, filters on bond_type '#', and returns the element and molecule_id of those atoms only.",
      "reason": "Query restricts to atoms that participate in the triple bond; elements present elsewhere in the same molecule (e.g., hydrogens) are omitted. Hence it does not list all elements contained in the molecules with triple bonds.",
      "verdict": false
    }
  },
  {
    "question_id": 562,
    "result": {
      "expected_answer": "Return the comment count for the post(s) whose view count equals 1910.",
      "sql_description": "Fetches the CommentCount from posts where ViewCount is exactly 1910, thus giving the number of comments for that post.",
      "reason": "Query applies the required view-count filter and returns the requested comment count; no missing or extra constraints.",
      "verdict": true,
      "evidence": "CommentCount → 1 (row 0)"
    }
  },
  {
    "question_id": 298,
    "result": {
      "expected_answer": "Percentage = (number of distinct molecules whose label is '+' and that contain at least one atom with element = 'h') ÷ (number of distinct molecules whose label is '+') * 100",
      "sql_description": "Joins molecule with atom, counts hydrogen-atom rows that belong to '+' molecules (numerator) and divides by the total distinct number of molecules in the database (denominator).",
      "reason": "Denominator is wrong anchor: it must be limited to carcinogenic ('+') molecules, not all molecules. Numerator counts hydrogen atoms, not distinct molecules, so molecules with multiple H atoms are over-counted. Fails required anchors for correct percentage definition.",
      "verdict": false
    }
  },
  {
    "question_id": 421,
    "result": {
      "expected_answer": "Names of the first three cards (alphabetically) whose power is unknown (NULL or '*') and whose promoTypes include 'arenaleague'.",
      "sql_description": "Filters cards where power is NULL or '*' and promoTypes contains 'arenaleague', orders the remaining rows by name A→Z, and returns the first three names.",
      "reason": "All required anchors—unknown power, arena league promo type, alphabetical ordering, and a limit of three—are correctly implemented.",
      "verdict": true,
      "evidence": "sql_result rows: [0] name='Arc Lightning', [1] name='Ashnod's Coupon', [2] name='Bonesplitter'"
    }
  },
  {
    "question_id": 546,
    "result": {
      "expected_answer": "List every distinct user display name such that the user owns at least one post whose ClosedDate is not NULL (i.e., a well-finished post).",
      "sql_description": "Joins users to posts on users.Id = posts.OwnerUserId, filters rows where posts.ClosedDate IS NOT NULL, then returns DISTINCT users.DisplayName.",
      "reason": "All required anchors are present: ownership via OwnerUserId and the well-finished criterion ClosedDate NOT NULL. The query selects distinct display names of those users, exactly matching the question.",
      "verdict": true,
      "evidence": "sql_result shows 20 distinct DisplayName rows such as Menno, Harvey Motulsky, Yahel, … indicating the query produced the list of qualifying users."
    }
  },
  {
    "question_id": 365,
    "result": {
      "expected_answer": "Return the card type (e.g., \"Creature — Human Knight\") for the card whose name is \"Benalish Knight\".",
      "sql_description": "Retrieves the 'type' field from the cards table for rows where name equals 'Benalish Knight'.",
      "reason": "Query filters precisely on the card name anchor and returns the requested type column. Duplicate identical rows do not alter the answer.",
      "verdict": true,
      "evidence": "sql_result shows column 'type' with four rows, all \"Creature — Human Knight\" (rows 0-3)."
    }
  },
  {
    "question_id": 464,
    "result": {
      "expected_answer": "All card names that belong to the set whose translation is exactly \"Hauptset Zehnte Edition\".",
      "sql_description": "Joins set_translations with cards via setCode, keeps only rows where translation = 'Hauptset Zehnte Edition', and returns the cards.name column.",
      "reason": "Correctly anchors on the target set through set_translations.translation and retrieves the corresponding card names; duplicates are permissible since uniqueness wasn’t requested.",
      "verdict": true,
      "evidence": "sql_result shows names column with examples like Abundance, Academy Researchers, Adarkar Wastes … representing cards in that set."
    }
  },
  {
    "question_id": 359,
    "result": {
      "expected_answer": "Return the original type description(s) (originalType) of the card whose name is exactly \"Ancestor's Chosen\".",
      "sql_description": "Selects the column originalType from the cards table for every row where name equals 'Ancestor''s Chosen'.",
      "reason": "Uses the correct column (originalType) that stores the type as originally printed and applies the required name filter. Extra rows/NULL are permissible because the question does not demand a single distinct value.",
      "verdict": true,
      "evidence": "sql_result shows originalType values: row0 \"Creature - Human Cleric\", row1 NULL, row2 \"Creature - Cleric\", row3 \"Creature — Human Cleric\"."
    }
  },
  {
    "question_id": 529,
    "result": {
      "expected_answer": "Names of all card sets that have at least one Korean translation entry in set_translations but have no Japanese translation entry.",
      "sql_description": "Checks each set; keeps those where a Korean translation exists (language='Korean') and no translation whose language contains 'Japanese' exists, then returns the set name.",
      "reason": "Query captures both required anchors: presence of a Korean translation and absence of any Japanese translation. LIKE '%Japanese%' safely matches the Japanese language values, so semantics align. Empty result is allowable if database contains none.",
      "verdict": true,
      "evidence": "sql_result returned 0 rows of column [name], consistent with potential lack of such sets."
    }
  },
  {
    "question_id": 411,
    "result": {
      "expected_answer": "The name of the illustrator (artist) of the card whose German card wording – found in the foreign-language data – exactly matches \"Das perfekte Gegenmittel zu einer dichten Formation.\"",
      "sql_description": "Finds the UUID of any foreign_data record whose TEXT field equals the given German sentence, then returns the artist of the card with that UUID.",
      "reason": "In the MTGJSON schema the sentence is almost certainly stored in foreign_data.flavorText (foreign flavour text), not in foreign_data.text (rules text). By searching the wrong column the query will miss the required card and therefore cannot supply the requested artist. Required anchor (matching the given sentence) is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 730,
    "result": {
      "expected_answer": "List of superhero names whose publisher is Marvel Comics and who possess the power named 'Super Strength'.",
      "sql_description": "Counts Marvel Comics superheroes and computes the percentage that have the 'Super Strength' power, returning a single numeric value.",
      "reason": "The query returns a percentage, not the requested list of superhero names. Required anchor (superhero names) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 710,
    "result": {
      "expected_answer": "A single integer: the number of comments whose score is exactly 0 among comments on posts whose CommentCount equals 1.",
      "sql_description": "Counts rows in comments where Score = 0 and the comment belongs to a post whose CommentCount is 1 (identified via a sub-query on posts).",
      "reason": "Query applies both required anchors: (1) filters posts to CommentCount = 1, (2) filters comments to Score = 0, then counts them. This directly yields the requested total.",
      "verdict": true,
      "evidence": "sql_result shows one column COUNT(*) with value 10997 (row 0), providing the requested count."
    }
  },
  {
    "question_id": 418,
    "result": {
      "expected_answer": "The printing availability (e.g., paper, mtgo, etc.) of the card(s) whose artist is Daren Bader.",
      "sql_description": "Retrieves the availability field for all records in cards where artist equals 'Daren Bader'.",
      "reason": "Query applies the required artist anchor and returns the availability column that the question equates to \"kind of printing\". Returning multiple rows is acceptable because the prompt does not specify a single card.",
      "verdict": true,
      "evidence": "sql_result shows availability values such as 'mtgo,paper' and 'paper' for rows 0-19."
    }
  },
  {
    "question_id": 835,
    "result": {
      "expected_answer": "A single number: the percentage of Marvel Comics superheroes whose alignment is 'Good'.",
      "sql_description": "Joins superhero with publisher and alignment, keeps rows where publisher_name = 'Marvel Comics', counts how many have alignment = 'Good', divides by total Marvel rows, multiplies by 100, returns that percentage.",
      "reason": "Includes required anchors: filters to Marvel Comics, checks alignment='Good', computes ratio over all Marvel heroes. Logic matches question intent.",
      "verdict": true,
      "evidence": "percentage_of_good_superheroes column returns 66.666667 (row 0)."
    }
  },
  {
    "question_id": 504,
    "result": {
      "expected_answer": "The count of cards that belong to the set whose name is 'World Championship Decks 2004' and whose converted mana cost equals 3.",
      "sql_description": "Joins sets and cards via set code, filters to s.name = 'World Championship Decks 2004' and c.convertedManaCost = 3, then returns COUNT(*) of the matching card rows (result: 10).",
      "reason": "All required anchors—set name filter and converted mana cost = 3—are correctly applied; query returns only the count, matching the question’s intent.",
      "verdict": true,
      "evidence": "COUNT(*) column shows 10 for the single returned row."
    }
  },
  {
    "question_id": 639,
    "result": {
      "expected_answer": "A single numeric value: the percentage (0‒100) of posts authored by the user whose DisplayName is \"Community\" that include the tag \"r\" (i.e., are written in/ about the R language).",
      "sql_description": "From posts written by the user \"Community\", counts total posts (COUNT(*)) and counts those whose Tags column contains the standalone tag \"r\" (using several INSTR patterns). It divides the latter by the total, multiplies by 100, and returns this percentage as column percentage.",
      "reason": "Query correctly anchors on posts owned by the user “Community” and computes ratio of posts whose tag list contains the standalone tag \"r\"; then expresses it as a percentage. Implementation details (string search vs. tag table) are permissible because schema does not mandate a particular storage format. All required anchors are satisfied and calculation logic is sound.",
      "verdict": true,
      "evidence": "Result column: percentage (row-0 → 0.0) – shows a valid numeric percentage derived from query."
    }
  },
  {
    "question_id": 522,
    "result": {
      "expected_answer": "All card–format pairs where the card has edhrecRank = 1 (i.e., is ranked first on EDHRec) and the card is banned in that play format; show the card name and the banned format.",
      "sql_description": "Joins cards to legalities on uuid, keeps rows with edhrecRank = 1 and status = 'Banned', returning columns name and format.",
      "reason": "Query applies both mandatory filters (edhrecRank = 1, status = 'Banned') and outputs the requested fields (card name, banned format). Extra duplicates from multiple printings are harmless because the question does not demand uniqueness.",
      "verdict": true,
      "evidence": "sql_result shows rows like (name='Sol Ring', format='duel' or 'legacy'), confirming the query returns name and format columns for banned formats of rank-1 cards."
    }
  },
  {
    "question_id": 832,
    "result": {
      "expected_answer": "The superhero name that corresponds to the maximum height_cm in the table (i.e., the tallest superhero).",
      "sql_description": "Retrieves superhero_name from superhero, orders rows by height_cm descending, and returns the first row, thus giving one name with the greatest height.",
      "reason": "Query correctly targets height_cm for maximal value and outputs the superhero name, satisfying the request for the tallest superhero. Handling of possible ties isn’t specified, so returning one is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows column superhero_name with value 'Surtur' in row 0."
    }
  },
  {
    "question_id": 400,
    "result": {
      "expected_answer": "A list of the setCode values for every card (or set) that has a Spanish translation – one row per distinct set code.",
      "sql_description": "Gets all rows in set_translations whose language equals 'Spanish' and returns the distinct setcode values.",
      "reason": "The query applies the required anchor (language = Spanish) and returns exactly the requested attribute (setCode), using DISTINCT to avoid duplicates. No other constraints are missed.",
      "verdict": true,
      "evidence": "sql_result shows column setCode with many distinct codes such as 10E, 4ED, … (rows 0-19)."
    }
  },
  {
    "question_id": 955,
    "result": {
      "expected_answer": "For every Formula-1 season with year < 1975, return that year together with the average finishing time (converted to seconds) of the race winners (champions) of all Grands Prix held in that season.",
      "sql_description": "Joins races with results, keeps every result row whose time is not NULL (all finishers), converts the time string to seconds, and computes the average of these times for each season of every year in the table (no year filter).",
      "reason": "Query omits two explicit anchors: 1) champion filter – it averages all finishers instead of only winners; 2) year < 1975 – it includes later seasons. Hence the returned values do not match the question’s requirements.",
      "verdict": false
    }
  },
  {
    "question_id": 515,
    "result": {
      "expected_answer": "The earliest non-null originalReleaseDate among mythic-rarity cards, together with every play format in which that specific card is legal.",
      "sql_description": "Joins cards to legalities, keeps rows where rarity = 'mythic' and status = 'Legal', orders by originalReleaseDate ascending, then returns the release date and a single format from the first row (LIMIT 1).",
      "reason": "1) Because NULL dates sort first, the query can choose a card lacking any release date (as shown by result None), not the true oldest dated card. 2) LIMIT 1 means it outputs only one legal format even when the card may be legal in several, so required formats are incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 685,
    "result": {
      "expected_answer": "Return one row containing: 1) the ViewCount (total views) of the post whose text is 'Computer Game Datasets'; 2) the DisplayName of the user who most recently posted/edited that post (i.e., the user associated with the latest occurrence in postHistory).",
      "sql_description": "Gets ViewCount from posts and the owner’s DisplayName by locating every post whose id appears at least once in postHistory with Text = 'Computer Game Datasets'. It does not determine which postHistory record is latest and always takes the post owner, not the last editor.",
      "reason": "The question explicitly asks for the user who posted it \"last time\" (latest revision). The query ignores recency and simply returns the post owner, so the required anchor of ‘last time’ is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1033,
    "result": {
      "expected_answer": "A single numeric value: the average height of all players whose birthday is on or after 1990-01-01 and before 1996-01-01.",
      "sql_description": "Filters Player rows where birthday >= '1990-01-01 00:00:00' and < '1996-01-01 00:00:00', then returns AVG(height).",
      "reason": "Matches required date range and correctly computes the average height; no missing anchors.",
      "verdict": true,
      "evidence": "AVG(height)=181.400601 (row 0, column AVG(height))"
    }
  },
  {
    "question_id": 599,
    "result": {
      "expected_answer": "1) All PostHistoryTypeId values for post 3720 (usually as a list or set).\n2) One number: the count of distinct users who commented on post 3720.",
      "sql_description": "Returns a single-column result that is the UNION of (a) PostHistoryTypeId values for post 3720 and (b) the distinct comment-user count for the same post.",
      "reason": "The two required answers are merged into one column; UNION also removes duplicates, so the user count can be lost if it equals an existing PostHistoryTypeId. The query does not provide the two separate pieces of information unambiguously.",
      "verdict": false
    }
  },
  {
    "question_id": 483,
    "result": {
      "expected_answer": "A list of the Italian rules text (foreign_data.text) for every card that belongs to the set named \"Coldsnap\".",
      "sql_description": "Joins sets to cards on set code and to foreign_data on uuid, then filters rows where the set name is 'Coldsnap' and the foreign language is 'Italian', returning the foreign_data.text field.",
      "reason": "All explicit anchors (set name = Coldsnap, language = Italian, field = rules text) are correctly applied; the query outputs the requested texts, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows one column 'text' with multiple Italian rules text rows (e.g., rows 0-19)."
    }
  },
  {
    "question_id": 954,
    "result": {
      "expected_answer": "A single numeric value: the percentage of race participations by Japanese drivers in 2007-2009 where the result time is not NULL (i.e., they finished), calculated as completed participations / total participations × 100.",
      "sql_description": "Joins races, results, drivers; keeps rows where drivers are Japanese and race year between 2007 and 2009; numerator counts rows with non-NULL time, denominator counts all such rows, then multiplies by 100.",
      "reason": "Matches all explicit anchors: nationality='Japanese', years 2007-2009, completion defined by time IS NOT NULL, ratio over same row set. Output is a single percentage value, fulfilling the question.",
      "verdict": true,
      "evidence": "sql_result has column completion_percentage with value 27.272727"
    }
  },
  {
    "question_id": 897,
    "result": {
      "expected_answer": "Full name (forename + surname) of the driver who has the greatest total number of wins, together with his nationality and the highest single-season (or single-standing) points value he achieved.",
      "sql_description": "For each surname–nationality pair, the query counts how many driverStandings rows exist (wins IS NOT NULL) and takes the average of points; it returns the pair with the largest row count, showing surname, nationality and that average.",
      "reason": "Anchors violated: 1) ‘most winning’ should compare the total wins (SUM or MAX of wins), not the number of rows. 2) ‘maximum point scores’ requires MAX(points), not AVG(points). 3) It returns only surname (missing forename). Therefore the SQL does not satisfy the question.",
      "verdict": false
    }
  },
  {
    "question_id": 814,
    "result": {
      "expected_answer": "Skin colour names (colour.colour) for every superhero who has any attribute record with attribute_value = 100.",
      "sql_description": "Joins hero_attribute to superhero and colour, filters rows where attribute_value = 100, and returns the skin colour of those heroes.",
      "reason": "Query enforces the only explicit anchor (attribute_value = 100) and correctly maps skin_colour_id to colour.id; it outputs the requested colour names, so it satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows a single column \"colour\" containing values such as 'No Colour', 'Grey', 'Blue', 'Green', 'White' etc., matching the requested data."
    }
  },
  {
    "question_id": 637,
    "result": {
      "expected_answer": "A list of every individual tag name (e.g., books, combinatorics, …) that appears on posts authored by the user with DisplayName = 'Mark Meckes' where CommentCount = 0. No other values should appear.",
      "sql_description": "Joins users to posts, restricts to Mark Meckes and CommentCount = 0, then returns DISTINCT values of the Posts.Tags column (which contains the raw '<tag1><tag2>…' string) including NULLs.",
      "reason": "It does filter by user and CommentCount=0, but it does not split multi-tag strings into individual tag names and it also returns a NULL row. Hence the output is not the precise set of tag names requested and contains extraneous data.",
      "verdict": false
    }
  },
  {
    "question_id": 638,
    "result": {
      "expected_answer": "A list of all user display names (DisplayName) for users who have earned at least one badge whose Name equals 'Organizer'.",
      "sql_description": "Joins badges to users on user id, filters badge rows where Name = 'Organizer', and returns DISTINCT users.DisplayName.",
      "reason": "Includes required anchor Badge Name='Organizer', joins to users to get names, returns distinct DisplayName values; thus fully satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows one column DisplayName (e.g., 'Harlan', 'Jason Punyon', …) consistent with expected list."
    }
  },
  {
    "question_id": 1087,
    "result": {
      "expected_answer": "A single integer: the count of unique players whose height is greater than 180 and whose volley (volleys) score is greater than 70.",
      "sql_description": "Counts all rows produced by joining Player and Player_Attributes where height > 180 and volleys > 70, returning 12,293 rows.",
      "reason": "COUNT(*) measures attribute rows, not distinct players. Players with multiple qualifying attribute records are over-counted, so the result is inflated and does not match the requested count of players.",
      "verdict": false
    }
  },
  {
    "question_id": 758,
    "result": {
      "expected_answer": "Hair colour(s) of every superhero whose race is 'human' and whose height_cm equals 185.",
      "sql_description": "Joins superhero with race and colour, filters rows where height_cm = 185 and race = 'Human', then returns the associated hair colour (c.colour).",
      "reason": "All required anchors—height 185, race human, hair colour via hair_colour_id—are present. Returning the colour field satisfies the request; duplicates/multiple rows are acceptable because the question doesn’t forbid them.",
      "verdict": true,
      "evidence": "sql_result shows column 'colour' with values such as Blond, Brown, Black, etc., confirming hair colours were retrieved."
    }
  },
  {
    "question_id": 1178,
    "result": {
      "expected_answer": "Return the SEX value (M or F) of the patient whose AORTITIS diagnosis record is earliest in the dataset (i.e., the first patient diagnosed with AORTITIS).",
      "sql_description": "Filters Patient rows to those with Diagnosis = 'AORTITIS', orders them by First Date ascending, then returns the SEX of the top row, giving the gender of the earliest-dated AORTITIS patient.",
      "reason": "Question asks for gender of the first AORTITIS patient; using First Date as the ordering criterion is a reasonable interpretation for identifying the first diagnosis given available columns. Query applies the diagnosis filter, orders by that date, and selects SEX, satisfying the requirement.",
      "verdict": true,
      "evidence": "sql_result row0: SEX = 'M'"
    }
  },
  {
    "question_id": 786,
    "result": {
      "expected_answer": "An integer representing how many heroes have a Strength attribute equal to the maximum Strength value among all heroes.",
      "sql_description": "Joins hero_attribute with attribute, filters rows where attribute_name = 'Strength', finds the MAX strength value, then counts how many hero_attribute rows have that exact value (i.e., heroes with the top strength).",
      "reason": "Query correctly anchors on attribute_name = 'Strength', matches attribute_value to the global MAX Strength value, and counts those heroes. This meets the question requirements; counting rows suffices since schema implies one Strength row per hero.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 63, providing the requested count."
    }
  },
  {
    "question_id": 808,
    "result": {
      "expected_answer": "Race value of any superhero whose weight is 108 kg and height is 188 cm.",
      "sql_description": "Joins superhero to race on race_id and returns race.race for every row where weight_kg = 108 and height_cm = 188.",
      "reason": "Query applies both required filters (weight 108, height 188) and outputs the requested race field; duplicates/unknown symbols do not violate the question.",
      "verdict": true,
      "evidence": "sql_result shows column race with rows like '-', 'Human' etc., matching race values for the filtered superheroes."
    }
  },
  {
    "question_id": 952,
    "result": {
      "expected_answer": "List of constructor names that have at least once been in position 1 in the constructorStandings table.",
      "sql_description": "Joins constructorStandings with constructors and returns the names where constructorStandings.position = 1 (no DISTINCT, so seasons with the same constructor appear multiple times).",
      "reason": "Query applies the required anchor (position = 1) and supplies the constructor names; duplicates do not violate the question’s intent.",
      "verdict": true,
      "evidence": "sql_result.name rows: McLaren (rows 0,1,14), BMW Sauber (2), Ferrari (3-16), Renault (17-19)"
    }
  },
  {
    "question_id": 1216,
    "result": {
      "expected_answer": "List all male patients whose albumin value is <= 3.5 or >= 5.5, ordered by their birthday from newest to oldest.",
      "sql_description": "Joins Patient and Laboratory, filters where SEX = 'M' and albumin is out-of-range, returns Patient.ID rows ordered by Patient.Birthday descending.",
      "reason": "All anchors (male, albumin out of normal range, sort by birthday descending) are present. Duplicate IDs from multiple lab records do not violate the question’s requirements per guideline neutrality toward duplicates.",
      "verdict": true,
      "evidence": "sql_result shows only Patient.ID column with multiple rows (IDs 3362815, 4007151, 5119703) appearing several times, consistent with expected male patients; ordering is descending by their single birthday value."
    }
  },
  {
    "question_id": 1022,
    "result": {
      "expected_answer": "Return the preferred_foot (left/right) of the player(s) whose potential value is the minimum among all players in Player_Attributes.",
      "sql_description": "Finds the minimal potential value in Player_Attributes, then returns preferred_foot for every row whose potential equals that minimum.",
      "reason": "Query correctly anchors on min(potential) and outputs preferred_foot. Extra duplicate rows are acceptable; they do not add incorrect values.",
      "verdict": true,
      "evidence": "sql_result shows two rows, column preferred_foot both 'right', matching the asked attribute."
    }
  },
  {
    "question_id": 591,
    "result": {
      "expected_answer": "The count of distinct users (unique UserId values) who received the “Supporter” badge in the year 2011.",
      "sql_description": "Counts all rows in badges where Name = 'Supporter' and the year(Date) = 2011, without DISTINCT; therefore it counts badge awards, not necessarily unique users.",
      "reason": "Question asks for number of users, implying a distinct UserId count. The query omits DISTINCT, so if any user earned the badge more than once it would over-count. Missing required distinct-users anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 899,
    "result": {
      "expected_answer": "Names of circuits that hosted exactly four Formula 1 races in the period 1990–2000 inclusive.",
      "sql_description": "Joins circuits with races, filters races whose year is between 1990 and 2000, groups by circuit name, keeps groups where the number of race rows is 4, and outputs the circuit names.",
      "reason": "Query applies correct year filter, counts races per circuit, enforces exactly four occurrences, and returns the circuit names as requested. All explicit anchors (year range, count=4, circuit list) are satisfied.",
      "verdict": true,
      "evidence": "sql_result rows: name → (0) A1-Ring, (1) Autódromo Juan y Oscar Gálvez"
    }
  },
  {
    "question_id": 732,
    "result": {
      "expected_answer": "Publisher name(s) of the superhero whose Speed attribute value is the minimum among all superheroes.",
      "sql_description": "Joins publisher, superhero, hero_attribute, and attribute tables; keeps rows where attribute_name = 'Speed'; orders them by attribute_value ascending so the slowest hero is first; returns that hero's publisher_name (one row via LIMIT 1).",
      "reason": "Query anchors on Speed, correctly targets minimum speed via ORDER BY ASC LIMIT 1, and outputs publisher_name, satisfying the question. Use of ORDER BY instead of MIN is acceptable for this purpose.",
      "verdict": true,
      "evidence": "sql_result shows publisher_name column with value 'Marvel Comics' (row 0), matching expected output format."
    }
  },
  {
    "question_id": 1315,
    "result": {
      "expected_answer": "A single integer: the count of Student_Club members who attended the event named \"Women's Soccer.\"",
      "sql_description": "Looks up the event_id whose name is \"Women's Soccer\" and counts distinct link_to_member entries in attendance for that event, returning the number of students.",
      "reason": "Query applies required event-name anchor and counts distinct attending students, matching the question. Attendance table already ensures uniqueness but DISTINCT is harmless.",
      "verdict": true,
      "evidence": "sql_result shows column number_of_students with value 17 (row 1), matching the requested count."
    }
  },
  {
    "question_id": 939,
    "result": {
      "expected_answer": "The number of British (\"UN\") drivers who competed in the 2008 Australian Grand Prix.",
      "sql_description": "Counts distinct drivers whose nationality is 'British' and who have a result entry for the race named 'Australian Grand Prix' in the year 2008.",
      "reason": "Query applies correct nationality filter, joins results with the specific 2008 Australian GP race, counts distinct drivers, matching the question’s requirements.",
      "verdict": true,
      "evidence": "sql_result shows driver_count = 4 (row 0, column driver_count)."
    }
  },
  {
    "question_id": 913,
    "result": {
      "expected_answer": "The name of the country that contains the circuit with the maximum value in the alt column (highest altitude).",
      "sql_description": "Selects country and circuit name from circuits, orders rows by altitude descending, and keeps the first row, thereby identifying the circuit with the greatest altitude and its country.",
      "reason": "Query applies the correct anchor (max altitude) and retrieves the country (plus the related circuit name). Extra column is related and does not invalidate the answer.",
      "verdict": true,
      "evidence": "sql_result shows country column = Malaysia (row 0), which is returned along with the circuit name."
    }
  },
  {
    "question_id": 1014,
    "result": {
      "expected_answer": "For every Formula-1 circuit located in Italy, return the single fastest lap time ever recorded there (i.e., the lap record) together with the circuit name.",
      "sql_description": "Joins lapTimes with races and circuits, filters circuits whose country is 'Italy', groups by circuit, and selects MIN(l.time) as the fastest lap time per circuit, outputting circuit name and that minimum time.",
      "reason": "Query anchors correctly on Italian circuits, and for each circuit returns the minimum recorded lap time, satisfying the definition of a lap record. No required constraint is missed.",
      "verdict": true,
      "evidence": "Returned columns: circuit_name, fastest_lap_time. Example rows: (Autodromo Nazionale di Monza, 15:14.219), (Autodromo Enzo e Dino Ferrari, 13:29.130)."
    }
  },
  {
    "question_id": 1071,
    "result": {
      "expected_answer": "Short name(s) of the team(s) whose buildUpPlaySpeed = 31, buildUpPlayDribbling = 53, and buildUpPlayPassing = 32.",
      "sql_description": "Joins Team with Team_Attributes and returns team_short_name for rows where buildUpPlaySpeed = 31, buildUpPlayDribbling = 53, and buildUpPlayPassing = 32.",
      "reason": "All required attribute anchors are applied; output column is the requested short name. Duplicate rows do not violate the question.",
      "verdict": true,
      "evidence": "team_short_name: [GLA, GLA]"
    }
  },
  {
    "question_id": 1533,
    "result": {
      "expected_answer": "For every customer who has at least one transaction of product 5 whose unit price (Price / Amount) exceeds 29.00, return that customer’s Consumption value recorded for the month 201208 (August 2012).",
      "sql_description": "Joins transactions_1k with yearmonth on CustomerID, keeps rows where ProductID = 5 and Price/Amount > 29, limits the yearmonth records to Date = '201208', and outputs the Consumption column.",
      "reason": "Query applies the correct unit-price filter, targets product 5, restricts consumption to August 2012, and returns the requested Consumption data. Duplicate rows per customer are harmless given the question wording; no required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows a single column \"Consumption\" with 10 matching rows (e.g., 1903.20, 88265.39 …), confirming the query retrieves consumption values."
    }
  },
  {
    "question_id": 1298,
    "result": {
      "expected_answer": "The number of distinct patients who have any laboratory record with total cholesterol (T-CHO) < 250 and who also have any ANA examination record whose ANA Pattern is 'P'.",
      "sql_description": "Counts all joined rows between Patient, Laboratory and Examination where T-CHO < 250 and ANA Pattern = 'P' using COUNT(T1.ID) without DISTINCT, therefore counting every matching row produced by the join instead of distinct patients.",
      "reason": "Question asks for patients, so duplicates across multiple lab/exam dates must be collapsed. Query omits DISTINCT, so if a patient has more than one qualifying Laboratory or Examination row the patient will be counted multiple times, inflating the result. Required anchor \"distinct patients\" is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 846,
    "result": {
      "expected_answer": "Driver reference names of the five slowest Q1 drivers (i.e., the ones eliminated after the first qualifying period) in raceId = 20.",
      "sql_description": "Gets all qualifying records for race 20, joins to drivers to obtain driverRef, orders by q1 time descending (slowest first) and returns the first five distinct driverRef values.",
      "reason": "Query honours race 20 filter, identifies the five highest (slowest) Q1 times – consistent with the elimination rule – and returns their driverRef names. No required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows 5 rows with column driverRef: ['sato', 'davidson', 'vettel', 'sutil', 'fisichella']."
    }
  },
  {
    "question_id": 990,
    "result": {
      "expected_answer": "Return the constructorRef and url of the constructor that won (was champion of) the 2009 Singapore Grand Prix race.",
      "sql_description": "Gets the constructor with the highest cumulative points in the season standings after the 2009 Singapore GP (constructorStandings), ordering by points and taking the top one, then returns its constructorRef and url.",
      "reason": "The query identifies the season points leader after the race, not the race-winning constructor. Champion of a Grand Prix normally means the race winner, which should be derived from the results table (position=1). Thus it returns Brawn instead of the winning constructor (McLaren). Missing the required anchor of race winner.",
      "verdict": false
    }
  },
  {
    "question_id": 1455,
    "result": {
      "expected_answer": "The identifier of the budget (budget.budget_id or other budget field) whose expense entry with description 'Water, chips, cookies' has the highest cost.",
      "sql_description": "Finds the maximum cost value among all expenses with description 'Water, chips, cookies'; returns only that numeric amount (69.33).",
      "reason": "Question asks for which budget, but SQL returns only the amount, not any budget identifier. Missing required anchor: budget identification.",
      "verdict": false
    }
  },
  {
    "question_id": 992,
    "result": {
      "expected_answer": "List every driver whose nationality is German and whose year of birth is from 1971 to 1985 inclusive; show full name (forename + surname), the Wikipedia URL, and the date of birth, ordered from the most recent birth downwards.",
      "sql_description": "Selects German drivers, keeps those whose dob year extracted via STRFTIME is between 1971 and 1985, returns forename||' '||surname as fullname, url, dob, and orders the rows by dob descending.",
      "reason": "All required anchors are satisfied: nationality filter = German, year(dob) between 1971-1985 inclusive, proper columns (fullname/url/dob), and descending dob ordering. No missing or contradicting constraints.",
      "verdict": true,
      "evidence": "sql_result shows rows with columns [fullname, url, dob] and dob values 1985-06-27 … 1975-06-30, matching the filters and descending order."
    }
  },
  {
    "question_id": 1006,
    "result": {
      "expected_answer": "The minimum lap time value (i.e., the quickest lap) among every recorded lap on all circuits.",
      "sql_description": "Fetches the column lapTimes.time for the lexicographically smallest TEXT value in the table by ordering the string‐formatted times ascending and taking the first row.",
      "reason": "Question requires the numerically fastest lap. The query compares the time column as plain TEXT, so lexicographic ordering can mis-rank values (e.g., '10:32.179' < '1:32.000'). The sample result already signals such mis-ordering. Therefore it does not reliably return the numeric minimum lap time.",
      "verdict": false
    }
  },
  {
    "question_id": 1175,
    "result": {
      "expected_answer": "Return the patient age (year difference between Examination Date and Birthday) and the doctor’s diagnosis for the examination whose laboratory record shows the single highest hemoglobin (HGB) value in the database.",
      "sql_description": "Joins Examination, Laboratory and Patient on ID only, sorts all joined rows by Laboratory.HGB descending, and returns the age (based on the Examination Date of whatever Examination row happens to pair with that top HGB) and its Diagnosis, limited to one row.",
      "reason": "The query identifies the highest HGB but fails to enforce that the Examination Date belongs to the same visit/lab measurement (no join on date). If a patient has multiple examinations the age/diagnosis may come from an unrelated examination, violating the required anchor \"at the time of the examination\" linked to the max-HGB reading.",
      "verdict": false
    }
  },
  {
    "question_id": 1065,
    "result": {
      "expected_answer": "All team_long_name values for teams whose buildUpPlaySpeedClass is 'Fast'.",
      "sql_description": "Joins Team with Team_Attributes on team_api_id and selects Team.team_long_name where buildUpPlaySpeedClass = 'Fast'; returns one row per matching attribute record (duplicates possible).",
      "reason": "Correctly applies the required anchor (speed class = 'Fast') and returns the requested field (team_long_name). Extra duplicates are permissible since the question does not explicitly demand DISTINCT.",
      "verdict": true,
      "evidence": "sql_result shows column team_long_name with rows such as Aberdeen, Arsenal, Bayer 04 Leverkusen etc., confirming retrieval of names for teams classified as Fast."
    }
  },
  {
    "question_id": 1054,
    "result": {
      "expected_answer": "The value(s) of the column defensive_work_rate for the player named David Wilson.",
      "sql_description": "Joins Player with Player_Attributes on player_fifa_api_id, filters rows where player_name = 'David Wilson', then returns the defensive_work_rate for all matching attribute records.",
      "reason": "Question only asks for defensive work rate of David Wilson; the query correctly filters by that name and returns the requested field. Returning multiple identical rows is acceptable since the value is the same and the question did not demand deduplication or a specific date.",
      "verdict": true,
      "evidence": "defensive_work_rate column values in result rows 0-12 are all \"medium\" indicating the rate."
    }
  },
  {
    "question_id": 1041,
    "result": {
      "expected_answer": "Names of teams whose build-up play dribbling class is 'Normal' and whose average chanceCreationPassing during January 2014 (2014-01-01 00:00:00 to 2014-01-31 00:00:00) is below the overall January 2014 average, listed in descending order of their chanceCreationPassing value.",
      "sql_description": "Gets teams with buildUpPlayDribblingClass='Normal' and any date in calendar year 2014, computes each team’s average chanceCreationPassing, keeps those below the overall 2014 average, and orders teams by the SUM (not average) of chanceCreationPassing descending.",
      "reason": "Fails explicit date anchor: required to restrict to January 2014 (≤ 2014-01-31 00:00:00) but uses date LIKE '2014%' which includes later months, so result may include records outside the target period. Therefore does not satisfy the question’s constraints.",
      "verdict": false
    }
  },
  {
    "question_id": 1526,
    "result": {
      "expected_answer": "Return the consumption decrease rate for the customer who spent a total of 634.8 on 2012-08-25, computed as (consumption in 2012 − consumption in 2013) / consumption in 2012.",
      "sql_description": "Finds customers whose transaction record on 2012-08-25 has Amount = 634.8, fetches their Consumption for Date = '201212' and '201312' from yearmonth, and outputs (2012 value − 2013 value)/2012 value.",
      "reason": "Anchor mismatch: the payment of 634.8 refers to total money spent, but the query filters Amount (= quantity) rather than total price (Price*Amount), so it may miss the intended customer. Also, it only looks at December rows, not the whole year, but the incorrect customer filter already breaks the core requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 1273,
    "result": {
      "expected_answer": "The number of distinct patients whose laboratory record shows a normal anti-SSB value (stored in the DB as either \"negative\" for '-' or \"0\" for '+-') and whose diagnosis is SLE.",
      "sql_description": "Counts distinct patient IDs where Laboratory.SSB is '-' or '0' and Patient.Diagnosis is 'SLE'.",
      "reason": "Question specifies that the database stores the '-' result as the string \"negative\", but the query filters on '-' instead. It therefore omits patients recorded with the value \"negative\", so the required anchor for normal anti-SSB is not fully satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1050,
    "result": {
      "expected_answer": "The value (e.g., 'right' or 'left') indicating the preferred attacking foot of the footballer with the latest (most recent) birthday in the database.",
      "sql_description": "Joins Player with Player_Attributes on player_fifa_api_id, sorts all joined rows by Player.birthday in descending order (youngest first), then returns the preferred_foot from the first row, effectively giving the preferred foot of the youngest player who has attribute data.",
      "reason": "Captures both required anchors: 1) identifies the youngest player via latest birthday, 2) retrieves that player’s preferred_foot. Possible duplicates/ties are acceptable given the question wording, and the inner join is reasonable since preferred_foot is only in Player_Attributes.",
      "verdict": true,
      "evidence": "sql_result shows one row with preferred_foot = 'right'."
    }
  },
  {
    "question_id": 91,
    "result": {
      "expected_answer": "Identify which year, 1995 or 1996, has the higher average unemployment rate across all districts (optionally with the two average values).",
      "sql_description": "Calculates the mean of A12 (1995 unemployment rate) and the mean of A13 (1996 unemployment rate) for every row in the district table, returning both averages.",
      "reason": "Question asks for a comparison; returning both yearly averages is acceptable because it lets the higher value be determined. The query correctly aggregates the unemployment rate columns for 1995 and 1996, with no missing anchors.",
      "verdict": true,
      "evidence": "avg_1995 column ≈3.07, avg_1996 column ≈3.79; the result shows 1996 is higher."
    }
  },
  {
    "question_id": 1148,
    "result": {
      "expected_answer": "A single numeric percentage: (number of players whose height < 180 cm AND overall_rating > 70) divided either by (a) all players, per evidence, or at minimum by the distinct players under 180 cm, then multiplied by 100.",
      "sql_description": "Counts every Player_Attributes row where the related player is <180 cm and overall_rating>70, divides by the count of players <180 cm, and multiplies by 100.",
      "reason": "1) Denominator uses only players <180 cm, contradicting evidence which divides by all players. 2) Numerator counts attribute records, not distinct players, heavily inflating the value (seen in 674%). Both issues violate the required anchors (correct base set and distinct players).",
      "verdict": false
    }
  },
  {
    "question_id": 1450,
    "result": {
      "expected_answer": "For each individual event that has more than 40 related income records, return the city and country/county of the event’s location.",
      "sql_description": "Joins events → attendance → income → zip_code, then groups by location (zip code) and its city and county, returning those locations whose aggregated number of income records exceeds 40.",
      "reason": "The query groups by location rather than by event, so it tests whether the TOTAL incomes for all events at a location exceed 40, not whether EACH event exceeds 40. Thus events with fewer than 41 incomes may be included if their location’s combined count is high. Required anchor 'per-event income count' is missing. Column ‘county’ may match a typo for ‘country’, but the grouping error already invalidates the answer.",
      "verdict": false
    }
  },
  {
    "question_id": 1168,
    "result": {
      "expected_answer": "Return two pieces of information for the oldest patient whose Diagnosis is 'SJS': 1) the date on which that patient’s laboratory test was performed, taken from Laboratory.Date, and 2) the patient’s age when they first came to the hospital, calculated as the year difference between Patient.First Date and Patient.Birthday.",
      "sql_description": "Joins Patient and Laboratory on patient ID, keeps only rows where Diagnosis = 'SJS'. Computes age as STRFTIME('%Y',First Date) − STRFTIME('%Y',Birthday). Orders rows by Birthday ascending (earliest birth → oldest) and returns the first row’s Laboratory.Date and the computed age.",
      "reason": "Satisfies all explicit anchors: filters to SJS, identifies the oldest by earliest birthday, calculates age at first visit, and outputs the lab-work date. If the patient has multiple lab records, any of them meets the wording, which doesn’t demand a specific lab date. Hence the query answers the question.",
      "verdict": true,
      "evidence": "Returned columns: Date='1981-07-31', age=69 for the oldest SJS patient (row 0)."
    }
  },
  {
    "question_id": 1512,
    "result": {
      "expected_answer": "The ID of the customer whose total spending (sum of Amount × Price) on 2012-08-25 was highest.",
      "sql_description": "Filters transactions to 2012-08-25, groups by CustomerID, sums Amount*Price for each, orders by that sum descending, and returns the top CustomerID.",
      "reason": "All required anchors (date 2012-08-25, total paid, top spender, customer) are satisfied. Calculation of payment as Amount*Price is a reasonable interpretation of 'paid the most'.",
      "verdict": true,
      "evidence": "sql_result shows CustomerID column with top row value 7938."
    }
  },
  {
    "question_id": 1235,
    "result": {
      "expected_answer": "List every patient whose red-blood-cell count is below 3.5, showing: patient ID, the diagnosis recorded in Patient.Diagnosis, and the patient’s age (current year minus birth year).",
      "sql_description": "Joins Patient with Laboratory, keeps rows where Laboratory.RBC < 3.5, and returns each matching row’s Patient.ID, Patient.Diagnosis, and age computed as year(now) minus year(Birthday).",
      "reason": "All required anchors are present: RBC threshold (<3.5) is enforced; output includes ID, diagnosis, and an age calculation. Duplicates due to multiple lab dates are permissible because the question does not demand distinct patients.",
      "verdict": true,
      "evidence": "sql_result columns: ID, Diagnosis, Age. Example rows: (0) 27654 – RA, SLE susp – 89; (10) 30609 – SLE, MCTD – 81; duplicates appear but are acceptable."
    }
  },
  {
    "question_id": 1160,
    "result": {
      "expected_answer": "Percentage = (number of female patients whose total-protein value is <6.0 or >8.5 at least once) ÷ (total number of female patients) × 100.",
      "sql_description": "Counts ALL laboratory rows for female patients where TP is out of range and divides that count by the number of female patients, then multiplies by 100.",
      "reason": "Numerator is row-based, not patient-based; a patient with multiple abnormal tests is over-counted, so the query does not compute the required patient-level percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 168,
    "result": {
      "expected_answer": "A single numeric percentage: (number of female clients ÷ total distinct clients) among clients whose accounts were opened in districts where average salary (A11) > 10000.",
      "sql_description": "Joins client–disp–account–district, keeps rows where the account’s district A11 > 10000, then divides the number of rows with gender='F' by the total number of rows, returning a percentage.",
      "reason": "Counts rows in disp, not DISTINCT clients, so the same client linked to multiple accounts or disposition types is double-counted. The question asks for percentage of clients, a required anchor; DISTINCT is missing, therefore result can be incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1152,
    "result": {
      "expected_answer": "Numeric ratio computed as (number of SLE patients admitted as in-patients '+') divided by (number of SLE patients treated as out-patients '-')",
      "sql_description": "Counts SLE patients with Admission='-' (outpatient) and divides that count by the count of SLE patients with Admission='+' (inpatient), i.e., outpatient ÷ inpatient.",
      "reason": "Explicit evidence states the ratio must be inpatient/outpatient; query returns the inverse (outpatient/inpatient), violating the anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1250,
    "result": {
      "expected_answer": "List of patient IDs for individuals diagnosed with SLE whose laboratory record shows a proteinuria (U-PRO) value between 0 and 30 (exclusive).",
      "sql_description": "Joins Patient and Laboratory, filters rows where Patient.Diagnosis = 'SLE' and Laboratory.U-PRO > 0 AND < 30, then returns DISTINCT patient IDs.",
      "reason": "Query enforces both required anchors: SLE diagnosis from Patient and normal proteinuria range from Laboratory; DISTINCT ensures patient-level output. Question does not require checking all tests, so at least one normal reading is a reasonable interpretation.",
      "verdict": true,
      "evidence": "sql_result shows 20 distinct IDs column named ID (e.g., 48473, 250391, …) satisfying the filters."
    }
  },
  {
    "question_id": 957,
    "result": {
      "expected_answer": "The count of Italian drivers (distinct driverId) who have at least one race result with time IS NULL, meaning they never finished that race.",
      "sql_description": "Counts every results row where the driver is Italian and milliseconds IS NULL, returning 2911 – a tally of non-finish occurrences, not distinct drivers, and using the wrong NULL indicator.",
      "reason": "1) Required anchor from evidence is time IS NULL, but the query filters on milliseconds IS NULL. 2) It counts result rows instead of distinct drivers, so even under a lenient interpretation it over-counts when a driver failed multiple times. Thus it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 300,
    "result": {
      "expected_answer": "List of atoms that belong to molecule TR186 – i.e., for each atom in TR186 give its identifying information or at least its element type.",
      "sql_description": "Fetches the element field for every row in atom where molecule_id = 'TR186', effectively listing the element of each atom that composes TR186 (duplicates retained, one row per atom).",
      "reason": "The term “atoms” can reasonably be interpreted as the concrete atoms constituting the molecule. Returning each atom’s element satisfies this interpretation because it enumerates every atom (one per row) anchored on TR186. Required anchor (molecule_id = 'TR186') is present; no other constraints are specified.",
      "verdict": true,
      "evidence": "sql_result shows 20 rows with elements c, n, h – matching atoms of TR186 (column: element)."
    }
  },
  {
    "question_id": 1249,
    "result": {
      "expected_answer": "All disease (Diagnosis) names associated with patients whose laboratory record shows proteinuria (U-PRO) of 30 or higher (above normal).",
      "sql_description": "Joins Patient with Laboratory on patient ID, filters rows where Laboratory.U-PRO >= 30, and outputs DISTINCT Patient.Diagnosis values.",
      "reason": "Satisfies the key anchor U-PRO >= 30 and returns the requested attribute (Diagnosis). Using DISTINCT is acceptable because the question can reasonably be interpreted as wanting the set of disease names rather than repeating duplicates per patient.",
      "verdict": true,
      "evidence": "sql_result shows a list of Diagnosis column values (e.g., rows 0-3: 'SLE, MCTD', 'Raynaud's phenomenon', 'SLE', 'PM/DM', ...), confirming the query returns disease names."
    }
  },
  {
    "question_id": 1387,
    "result": {
      "expected_answer": "Full name(s) (first_name + last_name) of the student member(s) responsible for the budget that belongs to the event named \"Yearly Kickoff\".",
      "sql_description": "Finds the event record with name 'Yearly Kickoff', gets its budget(s), then finds every expense made from those budgets and returns DISTINCT first and last names of the members tied to those expenses.",
      "reason": "Query anchors the correct event and navigates through the budget to the members. Treating members who appear on expenses of that budget as those 'entrusted to manage' is a reasonable, schema-consistent interpretation and yields the requested student names. No required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows columns first_name, last_name with two rows: (0) Sacha Harrison, (1) Elijah Allen."
    }
  },
  {
    "question_id": 1034,
    "result": {
      "expected_answer": "player_api_id(s) of the player record(s) whose overall_rating equals the maximum overall_rating among all Player_Attributes rows dated 2010",
      "sql_description": "returns every player_api_id from 2010 whose overall_rating is strictly greater than the average overall_rating for 2010",
      "reason": "Question (and evidence) requires the maximum overall_rating anchor, not just above-average. SQL uses AVG not MAX, so many non-max players are included; anchor violated",
      "verdict": false
    }
  },
  {
    "question_id": 1426,
    "result": {
      "expected_answer": "For every member whose major_name is 'Environmental Engineering', return three columns: the member's last_name together with that major's department and college.",
      "sql_description": "Joins member with major on link_to_major = major_id, keeps rows where major_name = 'Environmental Engineering', and outputs member.last_name, major.department, major.college.",
      "reason": "Query applies the required major filter and returns exactly the requested fields (last name, department, college). No anchors are missing or contradicted.",
      "verdict": true,
      "evidence": "sql_result shows columns last_name, department, college with two matching members (rows 0-1), demonstrating correct selection."
    }
  },
  {
    "question_id": 1253,
    "result": {
      "expected_answer": "The diagnosis of the patient whose IgA value is the highest among all lab records that fall within the normal range (80–500, inclusive).",
      "sql_description": "Looks at Laboratory rows with IGA between 80 and 500, orders them by IGA descending, keeps the top row, joins to Patient by ID, and returns that patient’s Diagnosis.",
      "reason": "Query enforces the normal-range anchor (80–500), correctly finds the maximum IGA within that set, identifies the corresponding patient, and retrieves the diagnosis. Possible ties are acceptable for a singular question; returning one diagnosis suffices.",
      "verdict": true,
      "evidence": "sql_result shows one row with column Diagnosis = 'BEHCET'."
    }
  },
  {
    "question_id": 1122,
    "result": {
      "expected_answer": "The player name(s) whose overall_rating is the maximum in the dataset – i.e., the strongest player(s).",
      "sql_description": "Fetches player_name joined with attributes, sorts all rows by overall_rating descending and returns the first 10 rows (not distinct).",
      "reason": "Query limits to 10 arbitrary top-rated rows instead of restricting to rows where overall_rating equals the global MAX. It can include players with lower ratings and duplicates, so the required anchor (max overall_rating only) is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1219,
    "result": {
      "expected_answer": "A single scalar: the average UA value (AVG(UA)) among patients whose UA is within the normal range (UA < 8.0 for males or < 6.5 for females) when considering only each patient’s most recent laboratory record.",
      "sql_description": "For each patient, it selects the laboratory row with the maximum Date (latest), keeps those where UA is normal with respect to the patient’s sex, and returns the average UA across those rows.",
      "reason": "Query correctly anchors on latest lab per patient via MAX(Date), applies sex-specific normal-range filters, and averages UA. No required constraint is missing or contradicted.",
      "verdict": true,
      "evidence": "sql_result shows one column AVG(l.ua) with value 4.298367, matching the requested single average."
    }
  },
  {
    "question_id": 1499,
    "result": {
      "expected_answer": "The maximum average monthly consumption (total yearly consumption divided by 12) among customers whose currency is EUR.",
      "sql_description": "For every customer with Currency='EUR', it sums all their Consumption values, divides by 12 to get an average monthly figure, then takes the MAX of those per-customer figures.",
      "reason": "All required anchors are present: it restricts to EUR customers, follows the given monthly-consumption formula (SUM/12), and returns the biggest value across customers. No contradictory constraints.",
      "verdict": true,
      "evidence": "sql_result shows a single column MAX(MonthlyConsumption) with value 85002.473333, matching the requested scalar answer."
    }
  },
  {
    "question_id": 1419,
    "result": {
      "expected_answer": "The category (type) of the event whose event_date is exactly '2020-03-24T12:00:00'.",
      "sql_description": "Selects the 'type' column from the event table for rows where event_date equals '2020-03-24T12:00:00'.",
      "reason": "Matches the required date anchor and returns the requested category field; no missing or extra constraints.",
      "verdict": true,
      "evidence": "sql_result shows type='Guest Speaker' in row 0"
    }
  },
  {
    "question_id": 1482,
    "result": {
      "expected_answer": "Identify, among the segments SME, LAM and KAM (EUR-only customers), which segment shows the greatest and which shows the smallest percentage increase in consumption from 2012 to 2013, where % increase = (consumption_2013 − consumption_2012) / consumption_2013 * 100.",
      "sql_description": "Computes 2012 and 2013 consumption per segment (EUR currency) and derives percentage_increase using (2013 − 2012) / 2012 * 100, then returns the segments with the highest and lowest percentages.",
      "reason": "Required anchor: denominator must be 2013 consumption, but query divides by 2012 consumption, contradicting the provided formula. Therefore the computed percentages – and possibly the ordering – are incorrect for the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1487,
    "result": {
      "expected_answer": "The identifier of the customer in the LAM segment whose currency is EUR and whose consumption is the highest for October 2013 (yearmonth 201310).",
      "sql_description": "Joins customers with yearmonth, keeps rows where Segment='LAM', Currency='EUR' and Date='201310', orders them by Consumption descending and returns the first CustomerID.",
      "reason": "Covers every required anchor: LAM segment, EUR currency, October 2013, and picks the maximum consumption via ORDER BY … DESC LIMIT 1. Result therefore answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column CustomerID = 3154, satisfying the requested output."
    }
  },
  {
    "question_id": 401,
    "result": {
      "expected_answer": "A single numeric percentage: (number of cards with frameEffects containing \"legendary\" AND isOnlineOnly = 1) divided by (total number of cards whose frameEffects contain \"legendary\") * 100.",
      "sql_description": "Filters cards to those with frameEffects containing \"legendary\". Within that set, counts records whose hand value is '+3' and divides by the total count of legendary-frame cards.",
      "reason": "Numerator anchor is wrong: the query uses hand = '+3' instead of isOnlineOnly = 1, so it does not measure \"only available in online game variations.\" Required anchor isOnlineOnly is missing, making the percentage unrelated to the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1195,
    "result": {
      "expected_answer": "The mean ALB (blood albumin) value among patients who are female (SEX = 'F'), have a diagnosis of SLE, and whose platelet count (PLT) exceeds 400.",
      "sql_description": "Joins Patient and Laboratory on ID, keeps rows where SEX = 'F', Diagnosis = 'SLE', and PLT > 400, then returns AVG(ALB) over those laboratory rows.",
      "reason": "Query applies all required filters (sex, diagnosis, platelet threshold) and computes the requested average albumin level; no required anchor is missing or contradicted.",
      "verdict": true,
      "evidence": "AVG(T2.ALB)=3.912308 in returned result"
    }
  },
  {
    "question_id": 1318,
    "result": {
      "expected_answer": "The name of the event with the greatest number of student-club members attending (i.e., event having the maximum attendance count).",
      "sql_description": "Joins attendance with member and event, counts how many member records exist per event, orders the events by this count descending, and returns the first (highest) event name.",
      "reason": "Query counts attendances per event and selects the one with the maximum count, satisfying the requirement. The join with member ensures counts are for student-club members; no required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows one column event_name with value 'Registration' in row 0."
    }
  },
  {
    "question_id": 1449,
    "result": {
      "expected_answer": "For each club member who has at least one expense with cost greater than 100 dollars, return the member’s first name, last name, and the name of the member’s major.",
      "sql_description": "Joins member to major to expense, filters expenses with cost > 100 and outputs the member’s first_name, last_name, and major_name.",
      "reason": "Captures the required cost > 100 anchor and returns the requested attributes (first & last name, major). Duplicate rows from multiple qualifying expenses are acceptable because the question does not forbid them.",
      "verdict": true,
      "evidence": "first_name, last_name, major_name columns returned; e.g., rows like (Sacha, Harrison, Liberal Arts) and (Elijah, Allen, Elementary Education)."
    }
  },
  {
    "question_id": 500,
    "result": {
      "expected_answer": "All Japanese set names (translations) for any set that includes the card named \"Fellwar Stone\".",
      "sql_description": "Joins cards with set_translations on set code, keeps rows where card name is 'Fellwar Stone' and translation language is 'Japanese', then returns the distinct translation values.",
      "reason": "Satisfies both anchors: filters by the card name and by Japanese language, and outputs the set translation(s). Duplicates are removed; returning a NULL alongside names is harmless since the question does not forbid it.",
      "verdict": true,
      "evidence": "translation rows include e.g. '第９版 基本セット', 'Commander (2015 Edition)', 'Commander (2016 Edition)', 'Commander (2017 EDITION)', 'Magic: the Gathering Commander', plus one NULL."
    }
  },
  {
    "question_id": 1458,
    "result": {
      "expected_answer": "A single numeric value representing (percentage of members from New Jersey) minus (percentage of members from Vermont), relative to all club members; may be expressed as a percentage or a decimal.",
      "sql_description": "Computes ((members from Maine) / total members – (members from Vermont) / total members) * 100, rounded to two decimals, considering only rows where position = 'Member'.",
      "reason": "Required anchor ‘New Jersey’ is replaced by ‘Maine’, so the calculation uses the wrong state and does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1509,
    "result": {
      "expected_answer": "A single number: the count of transaction records where the gas station’s Country is 'CZE' and the transaction date is later than 2012-01-01.",
      "sql_description": "Joins gasstations and transactions_1k on GasStationID, keeps rows with Country='CZE' and Date>'2012-01-01', then returns COUNT(*).",
      "reason": "All stated anchors (Czech Republic gas stations, date after 2012-01-01, counting transactions) are correctly applied; no extraneous conditions.",
      "verdict": true,
      "evidence": "Result has column COUNT(*) = 933 (row 1)"
    }
  },
  {
    "question_id": 1527,
    "result": {
      "expected_answer": "Identify the gas station (represented by its GasStationID) whose transactions generate the greatest total revenue across the entire transactions_1k table.",
      "sql_description": "Calculates revenue for each gas station as SUM(amount * price), orders the gas stations by this revenue in descending order, and returns the single GasStationID with the largest revenue.",
      "reason": "The query implements a plausible definition of revenue (quantity × price) and correctly selects the gas station with the maximum such total. All anchors (gas-station scope and highest revenue) are satisfied; no extraneous conditions are added.",
      "verdict": true,
      "evidence": "sql_result row0: GasStationID = 3250"
    }
  },
  {
    "question_id": 594,
    "result": {
      "expected_answer": "Return the name (or identifier) of the user who owns post with Id = 1 together with that user’s reputation value.",
      "sql_description": "Joins posts to users via OwnerUserId and selects the user’s DisplayName and Reputation for the row where posts.Id = 1.",
      "reason": "All required anchors are present: it filters on post id 1 and retrieves that user’s display name and reputation. This directly answers the question.",
      "verdict": true,
      "evidence": "sql_result rows: [0] DisplayName='csgillespie', Reputation=6764"
    }
  },
  {
    "question_id": 742,
    "result": {
      "expected_answer": "The total number (integer) of superheroes whose race is Vampire.",
      "sql_description": "Counts the number of rows in superhero joined to race where race = 'Vampire'. Returns that count.",
      "reason": "Query correctly filters superheroes to those with race 'Vampire' via join and counts them; fulfills the question’s requirement.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(T1.id) = 2 in the only row returned."
    }
  },
  {
    "question_id": 895,
    "result": {
      "expected_answer": "A single numeric value: the average lap time (in milliseconds) for driver Lewis Hamilton during the 2009 Malaysian Grand Prix.",
      "sql_description": "Calculates AVG(lapTimes.time) for records where the driverRef is 'vettel' and the race is the 2009 Chinese Grand Prix.",
      "reason": "Uses wrong driver (Sebastian Vettel instead of Lewis Hamilton), wrong race (Chinese instead of Malaysian), and wrong column (time text vs milliseconds). Violates required anchors on driver and race.",
      "verdict": false
    }
  },
  {
    "question_id": 967,
    "result": {
      "expected_answer": "A list of the 3 driver codes corresponding to the youngest (most recently born) drivers and, in addition, the count of how many of these three have nationality 'Netherlandic' or 'Dutch'.",
      "sql_description": "Chooses the 3 drivers with the earliest birth dates (oldest) using ORDER BY dob ASC, then returns a single row with one (nondeterministic) code and the sum of Dutch nationality flags across the three.",
      "reason": "1) Uses ASC so picks oldest, not youngest; anchor on youth violated. 2) Returns only one code instead of three. 3) GROUP BY missing so code value arbitrary/NULL. Therefore query does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1035,
    "result": {
      "expected_answer": "team_fifa_api_id values for teams whose buildUpPlaySpeed is strictly greater than 50 and strictly less than 60.",
      "sql_description": "Retrieves team_fifa_api_id from Team_Attributes rows where buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60 (no further filters).",
      "reason": "Query applies the exact numeric bounds required and returns the requested field; duplicates are acceptable as the question does not demand DISTINCT.",
      "verdict": true,
      "evidence": "sql_result shows one column team_fifa_api_id with several ids (e.g., 434, 77, 614 ...), consistent with the query description."
    }
  },
  {
    "question_id": 1145,
    "result": {
      "expected_answer": "Names of the four leagues that hosted the highest number of matches during the 2015/2016 season, i.e., top-4 leagues by game count.",
      "sql_description": "Counts matches per league for season '2015/2016', orders them by descending count, but returns only the single league with the highest count (LIMIT 1).",
      "reason": "Query satisfies season filter and ranking logic but fails to return the requested top FOUR leagues; it outputs only the top ONE.",
      "verdict": false
    }
  },
  {
    "question_id": 1225,
    "result": {
      "expected_answer": "For each sex (male and female), list the distinct patient IDs whose total bilirubin (T-BIL) value is 2.0 or higher (i.e., outside the normal range).",
      "sql_description": "Joins Laboratory with Patient, filters rows where T-BIL >= 2.0, groups by Patient.SEX, and concatenates the distinct patient IDs in each sex group.",
      "reason": "All required anchors are met: abnormal threshold (>=2.0), grouping by sex, and listing patient IDs via GROUP_CONCAT DISTINCT. Output columns and grouping match the question intent.",
      "verdict": true,
      "evidence": "Rows: [0] SEX='F', IDs='250391,1180510,2308236,2931207,4862013'; [1] SEX='M', IDs='43003,444499,1137040,2307640,4618443'"
    }
  },
  {
    "question_id": 1338,
    "result": {
      "expected_answer": "For every expense linked to the October Meeting held on 2019-10-08, report whether it was approved (true/false).",
      "sql_description": "Retrieves all expenses belonging to members who attended the event whose name is 'October Meeting' and whose date is '2019-10-08T12:00:00', returning each expense_id together with its approved flag.",
      "reason": "The query anchors on the correct event name and date, links attendees to their expenses, and outputs the approval status for each expense, directly answering whether each expense was approved. Given the schema, associating expenses to the event through the attending members is a reasonable interpretation, and the returned rows show the needed true/false values.",
      "verdict": true,
      "evidence": "sql_result columns: expense_id, approved – 20 rows, all but one show approved=true, one shows approved=NULL (row 15)."
    }
  },
  {
    "question_id": 1475,
    "result": {
      "expected_answer": "The count of DISTINCT customers whose segment is 'KAM' and whose TOTAL consumption summed over all months of 2012 (dates between 201201 and 201212) is less than 30,000.",
      "sql_description": "Counts every row in yearmonth having Segment='KAM', Date between 201201 and 201212, and monthly Consumption < 30000, without DISTINCT or yearly aggregation.",
      "reason": "1) Duplicates: same customer appearing in several months is counted multiple times, violating the \"how many customers\" anchor. 2) Consumption condition should apply to the customer’s yearly total, not to each month separately. Thus the query inflates counts and tests the wrong metric.",
      "verdict": false
    }
  },
  {
    "question_id": 934,
    "result": {
      "expected_answer": "Forename and surname of the driver who started the 1989 Australian Grand Prix from grid position 4.",
      "sql_description": "Joins races, results and drivers; filters to the 1989 Australian Grand Prix and grid=4; returns the driver's forename and surname.",
      "reason": "All required anchors (race name, year 1989, grid=4) are present and correctly linked; output columns match requested information.",
      "verdict": true,
      "evidence": "Row0: forename='Alessandro', surname='Nannini'"
    }
  },
  {
    "question_id": 363,
    "result": {
      "expected_answer": "A single integer: the number of distinct cards that (a) have at least one legality entry whose status is 'restricted' and (b) are flagged as being in a starter deck (isStarter = 1).",
      "sql_description": "Counts every row produced by joining cards to legalities where legalities.status = 'Restricted' and cards.isStarter = 1 (COUNT(c.id)), without removing duplicates that may arise if a card is restricted in more than one format.",
      "reason": "Question asks for how many cards, implying distinct cards. The query may over-count because it does not use DISTINCT after joining to legalities; a card with multiple 'Restricted' legality rows would be counted multiple times. Therefore it does not reliably give the requested count of cards.",
      "verdict": false
    }
  },
  {
    "question_id": 1209,
    "result": {
      "expected_answer": "Diagnoses of all patients whose ALT (GPT) value is above 60, listed in ascending order of the patients’ birthdays (oldest → youngest).",
      "sql_description": "Joins Laboratory and Patient, keeps rows where GPT > 60, then returns the DISTINCT Patient.Diagnosis values sorted by Patient.Birthday in ascending order.",
      "reason": "Query applies the required GPT > 60 filter and orders by birthday ascending, producing the requested diagnosis field. The DISTINCT clause only removes duplicate diagnosis strings; the question does not require repetition per patient, so this is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows a single column \"Diagnosis\" with 20 rows (e.g., rows 0-3: 'Adult STILL', 'PSS, RA susp', 'PNc', 'MRA, SJS', …), indicating diagnoses for qualifying patients."
    }
  }
]